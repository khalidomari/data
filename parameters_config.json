{
    "classifiers": [
        {
            "classifier": "sklearn.ensemble.AdaBoostClassifier",
            "name": "Ada Boost Classifier",
            "default_values": [
                {
                    "key": "algorithm",
                    "value": "SAMME.R",
                    "type_": "str"
                },
                {
                    "key": "learning_rate",
                    "value": 1.0,
                    "type_": "float"
                },
                {
                    "key": "n_estimators",
                    "value": 50,
                    "type_": "int"
                }
            ],
            "doc_string": "An AdaBoost classifier.\n\n    An AdaBoost [1] classifier is a meta-estimator that begins by fitting a\n    classifier on the original dataset and then fits additional copies of the\n    classifier on the same dataset but where the weights of incorrectly\n    classified instances are adjusted such that subsequent classifiers focus\n    more on difficult cases.\n\n    This class implements the algorithm known as AdaBoost-SAMME [2].\n\n    Read more in the :ref:`User Guide <adaboost>`.\n\n    Parameters\n    ----------\n    base_estimator : object, optional (default=None)\n        The base estimator from which the boosted ensemble is built.\n        Support for sample weighting is required, as well as proper\n        ``classes_`` and ``n_classes_`` attributes. If ``None``, then\n        the base estimator is ``DecisionTreeClassifier(max_depth=1)``\n\n    n_estimators : integer, optional (default=50)\n        The maximum number of estimators at which boosting is terminated.\n        In case of perfect fit, the learning procedure is stopped early.\n\n    learning_rate : float, optional (default=1.)\n        Learning rate shrinks the contribution of each classifier by\n        ``learning_rate``. There is a trade-off between ``learning_rate`` and\n        ``n_estimators``.\n\n    algorithm : {'SAMME', 'SAMME.R'}, optional (default='SAMME.R')\n        If 'SAMME.R' then use the SAMME.R real boosting algorithm.\n        ``base_estimator`` must support calculation of class probabilities.\n        If 'SAMME' then use the SAMME discrete boosting algorithm.\n        The SAMME.R algorithm typically converges faster than SAMME,\n        achieving a lower test error with fewer boosting iterations.\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    Attributes\n    ----------\n    estimators_ : list of classifiers\n        The collection of fitted sub-estimators.\n\n    classes_ : array of shape = [n_classes]\n        The classes labels.\n\n    n_classes_ : int\n        The number of classes.\n\n    estimator_weights_ : array of floats\n        Weights for each estimator in the boosted ensemble.\n\n    estimator_errors_ : array of floats\n        Classification error for each estimator in the boosted\n        ensemble.\n\n    feature_importances_ : array of shape = [n_features]\n        The feature importances if supported by the ``base_estimator``.\n\n    See also\n    --------\n    AdaBoostRegressor, GradientBoostingClassifier,\n    sklearn.tree.DecisionTreeClassifier\n\n    References\n    ----------\n    .. [1] Y. Freund, R. Schapire, \"A Decision-Theoretic Generalization of\n           on-Line Learning and an Application to Boosting\", 1995.\n\n    .. [2] J. Zhu, H. Zou, S. Rosset, T. Hastie, \"Multi-class AdaBoost\", 2009.\n\n    "
        },
        {
            "classifier": "sklearn.ensemble.BaggingClassifier",
            "name": "Bagging Classifier",
            "default_values": [
                {
                    "key": "bootstrap",
                    "value": true,
                    "type_": "bool"
                },
                {
                    "key": "bootstrap_features",
                    "value": false,
                    "type_": "bool"
                },
                {
                    "key": "max_features",
                    "value": 1.0,
                    "type_": "float"
                },
                {
                    "key": "max_samples",
                    "value": 1.0,
                    "type_": "float"
                },
                {
                    "key": "n_estimators",
                    "value": 10,
                    "type_": "int"
                },
                {
                    "key": "oob_score",
                    "value": false,
                    "type_": "bool"
                },
                {
                    "key": "verbose",
                    "value": 0,
                    "type_": "int"
                },
                {
                    "key": "warm_start",
                    "value": false,
                    "type_": "bool"
                }
            ],
            "doc_string": "A Bagging classifier.\n\n    A Bagging classifier is an ensemble meta-estimator that fits base\n    classifiers each on random subsets of the original dataset and then\n    aggregate their individual predictions (either by voting or by averaging)\n    to form a final prediction. Such a meta-estimator can typically be used as\n    a way to reduce the variance of a black-box estimator (e.g., a decision\n    tree), by introducing randomization into its construction procedure and\n    then making an ensemble out of it.\n\n    This algorithm encompasses several works from the literature. When random\n    subsets of the dataset are drawn as random subsets of the samples, then\n    this algorithm is known as Pasting [1]_. If samples are drawn with\n    replacement, then the method is known as Bagging [2]_. When random subsets\n    of the dataset are drawn as random subsets of the features, then the method\n    is known as Random Subspaces [3]_. Finally, when base estimators are built\n    on subsets of both samples and features, then the method is known as\n    Random Patches [4]_.\n\n    Read more in the :ref:`User Guide <bagging>`.\n\n    Parameters\n    ----------\n    base_estimator : object or None, optional (default=None)\n        The base estimator to fit on random subsets of the dataset.\n        If None, then the base estimator is a decision tree.\n\n    n_estimators : int, optional (default=10)\n        The number of base estimators in the ensemble.\n\n    max_samples : int or float, optional (default=1.0)\n        The number of samples to draw from X to train each base estimator.\n\n        - If int, then draw `max_samples` samples.\n        - If float, then draw `max_samples * X.shape[0]` samples.\n\n    max_features : int or float, optional (default=1.0)\n        The number of features to draw from X to train each base estimator.\n\n        - If int, then draw `max_features` features.\n        - If float, then draw `max_features * X.shape[1]` features.\n\n    bootstrap : boolean, optional (default=True)\n        Whether samples are drawn with replacement.\n\n    bootstrap_features : boolean, optional (default=False)\n        Whether features are drawn with replacement.\n\n    oob_score : bool, optional (default=False)\n        Whether to use out-of-bag samples to estimate\n        the generalization error.\n\n    warm_start : bool, optional (default=False)\n        When set to True, reuse the solution of the previous call to fit\n        and add more estimators to the ensemble, otherwise, just fit\n        a whole new ensemble. See :term:`the Glossary <warm_start>`.\n\n        .. versionadded:: 0.17\n           *warm_start* constructor parameter.\n\n    n_jobs : int or None, optional (default=None)\n        The number of jobs to run in parallel for both `fit` and `predict`.\n        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n        ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n        for more details.\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    verbose : int, optional (default=0)\n        Controls the verbosity when fitting and predicting.\n\n    Attributes\n    ----------\n    base_estimator_ : estimator\n        The base estimator from which the ensemble is grown.\n\n    estimators_ : list of estimators\n        The collection of fitted base estimators.\n\n    estimators_samples_ : list of arrays\n        The subset of drawn samples (i.e., the in-bag samples) for each base\n        estimator. Each subset is defined by an array of the indices selected.\n\n    estimators_features_ : list of arrays\n        The subset of drawn features for each base estimator.\n\n    classes_ : array of shape = [n_classes]\n        The classes labels.\n\n    n_classes_ : int or list\n        The number of classes.\n\n    oob_score_ : float\n        Score of the training dataset obtained using an out-of-bag estimate.\n\n    oob_decision_function_ : array of shape = [n_samples, n_classes]\n        Decision function computed with out-of-bag estimate on the training\n        set. If n_estimators is small it might be possible that a data point\n        was never left out during the bootstrap. In this case,\n        `oob_decision_function_` might contain NaN.\n\n    References\n    ----------\n\n    .. [1] L. Breiman, \"Pasting small votes for classification in large\n           databases and on-line\", Machine Learning, 36(1), 85-103, 1999.\n\n    .. [2] L. Breiman, \"Bagging predictors\", Machine Learning, 24(2), 123-140,\n           1996.\n\n    .. [3] T. Ho, \"The random subspace method for constructing decision\n           forests\", Pattern Analysis and Machine Intelligence, 20(8), 832-844,\n           1998.\n\n    .. [4] G. Louppe and P. Geurts, \"Ensembles on Random Patches\", Machine\n           Learning and Knowledge Discovery in Databases, 346-361, 2012.\n    "
        },
        {
            "classifier": "sklearn.ensemble.ExtraTreesClassifier",
            "name": "Extra Trees Classifier",
            "default_values": [
                {
                    "key": "bootstrap",
                    "value": false,
                    "type_": "bool"
                },
                {
                    "key": "criterion",
                    "value": "gini",
                    "type_": "str"
                },
                {
                    "key": "max_features",
                    "value": "auto",
                    "type_": "str"
                },
                {
                    "key": "min_impurity_decrease",
                    "value": 0.0,
                    "type_": "float"
                },
                {
                    "key": "min_samples_leaf",
                    "value": 1,
                    "type_": "int"
                },
                {
                    "key": "min_samples_split",
                    "value": 2,
                    "type_": "int"
                },
                {
                    "key": "min_weight_fraction_leaf",
                    "value": 0.0,
                    "type_": "float"
                },
                {
                    "key": "n_estimators",
                    "value": "warn",
                    "type_": "str"
                },
                {
                    "key": "oob_score",
                    "value": false,
                    "type_": "bool"
                },
                {
                    "key": "verbose",
                    "value": 0,
                    "type_": "int"
                },
                {
                    "key": "warm_start",
                    "value": false,
                    "type_": "bool"
                }
            ],
            "doc_string": "An extra-trees classifier.\n\n    This class implements a meta estimator that fits a number of\n    randomized decision trees (a.k.a. extra-trees) on various sub-samples\n    of the dataset and uses averaging to improve the predictive accuracy\n    and control over-fitting.\n\n    Read more in the :ref:`User Guide <forest>`.\n\n    Parameters\n    ----------\n    n_estimators : integer, optional (default=10)\n        The number of trees in the forest.\n\n        .. versionchanged:: 0.20\n           The default value of ``n_estimators`` will change from 10 in\n           version 0.20 to 100 in version 0.22.\n\n    criterion : string, optional (default=\"gini\")\n        The function to measure the quality of a split. Supported criteria are\n        \"gini\" for the Gini impurity and \"entropy\" for the information gain.\n\n    max_depth : integer or None, optional (default=None)\n        The maximum depth of the tree. If None, then nodes are expanded until\n        all leaves are pure or until all leaves contain less than\n        min_samples_split samples.\n\n    min_samples_split : int, float, optional (default=2)\n        The minimum number of samples required to split an internal node:\n\n        - If int, then consider `min_samples_split` as the minimum number.\n        - If float, then `min_samples_split` is a fraction and\n          `ceil(min_samples_split * n_samples)` are the minimum\n          number of samples for each split.\n\n        .. versionchanged:: 0.18\n           Added float values for fractions.\n\n    min_samples_leaf : int, float, optional (default=1)\n        The minimum number of samples required to be at a leaf node.\n        A split point at any depth will only be considered if it leaves at\n        least ``min_samples_leaf`` training samples in each of the left and\n        right branches.  This may have the effect of smoothing the model,\n        especially in regression.\n\n        - If int, then consider `min_samples_leaf` as the minimum number.\n        - If float, then `min_samples_leaf` is a fraction and\n          `ceil(min_samples_leaf * n_samples)` are the minimum\n          number of samples for each node.\n\n        .. versionchanged:: 0.18\n           Added float values for fractions.\n\n    min_weight_fraction_leaf : float, optional (default=0.)\n        The minimum weighted fraction of the sum total of weights (of all\n        the input samples) required to be at a leaf node. Samples have\n        equal weight when sample_weight is not provided.\n\n    max_features : int, float, string or None, optional (default=\"auto\")\n        The number of features to consider when looking for the best split:\n\n        - If int, then consider `max_features` features at each split.\n        - If float, then `max_features` is a fraction and\n          `int(max_features * n_features)` features are considered at each\n          split.\n        - If \"auto\", then `max_features=sqrt(n_features)`.\n        - If \"sqrt\", then `max_features=sqrt(n_features)`.\n        - If \"log2\", then `max_features=log2(n_features)`.\n        - If None, then `max_features=n_features`.\n\n        Note: the search for a split does not stop until at least one\n        valid partition of the node samples is found, even if it requires to\n        effectively inspect more than ``max_features`` features.\n\n    max_leaf_nodes : int or None, optional (default=None)\n        Grow trees with ``max_leaf_nodes`` in best-first fashion.\n        Best nodes are defined as relative reduction in impurity.\n        If None then unlimited number of leaf nodes.\n\n    min_impurity_decrease : float, optional (default=0.)\n        A node will be split if this split induces a decrease of the impurity\n        greater than or equal to this value.\n\n        The weighted impurity decrease equation is the following::\n\n            N_t / N * (impurity - N_t_R / N_t * right_impurity\n                                - N_t_L / N_t * left_impurity)\n\n        where ``N`` is the total number of samples, ``N_t`` is the number of\n        samples at the current node, ``N_t_L`` is the number of samples in the\n        left child, and ``N_t_R`` is the number of samples in the right child.\n\n        ``N``, ``N_t``, ``N_t_R`` and ``N_t_L`` all refer to the weighted sum,\n        if ``sample_weight`` is passed.\n\n        .. versionadded:: 0.19\n\n    min_impurity_split : float,\n        Threshold for early stopping in tree growth. A node will split\n        if its impurity is above the threshold, otherwise it is a leaf.\n\n        .. deprecated:: 0.19\n           ``min_impurity_split`` has been deprecated in favor of\n           ``min_impurity_decrease`` in 0.19 and will be removed in 0.21.\n           Use ``min_impurity_decrease`` instead.\n\n    bootstrap : boolean, optional (default=False)\n        Whether bootstrap samples are used when building trees.\n\n    oob_score : bool, optional (default=False)\n        Whether to use out-of-bag samples to estimate\n        the generalization accuracy.\n\n    n_jobs : int or None, optional (default=None)\n        The number of jobs to run in parallel for both `fit` and `predict`.\n        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n        ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n        for more details.\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    verbose : int, optional (default=0)\n        Controls the verbosity when fitting and predicting.\n\n    warm_start : bool, optional (default=False)\n        When set to ``True``, reuse the solution of the previous call to fit\n        and add more estimators to the ensemble, otherwise, just fit a whole\n        new forest. See :term:`the Glossary <warm_start>`.\n\n    class_weight : dict, list of dicts, \"balanced\", \"balanced_subsample\" or     None, optional (default=None)\n        Weights associated with classes in the form ``{class_label: weight}``.\n        If not given, all classes are supposed to have weight one. For\n        multi-output problems, a list of dicts can be provided in the same\n        order as the columns of y.\n\n        Note that for multioutput (including multilabel) weights should be\n        defined for each class of every column in its own dict. For example,\n        for four-class multilabel classification weights should be\n        [{0: 1, 1: 1}, {0: 1, 1: 5}, {0: 1, 1: 1}, {0: 1, 1: 1}] instead of\n        [{1:1}, {2:5}, {3:1}, {4:1}].\n\n        The \"balanced\" mode uses the values of y to automatically adjust\n        weights inversely proportional to class frequencies in the input data\n        as ``n_samples / (n_classes * np.bincount(y))``\n\n        The \"balanced_subsample\" mode is the same as \"balanced\" except that weights are\n        computed based on the bootstrap sample for every tree grown.\n\n        For multi-output, the weights of each column of y will be multiplied.\n\n        Note that these weights will be multiplied with sample_weight (passed\n        through the fit method) if sample_weight is specified.\n\n    Attributes\n    ----------\n    estimators_ : list of DecisionTreeClassifier\n        The collection of fitted sub-estimators.\n\n    classes_ : array of shape = [n_classes] or a list of such arrays\n        The classes labels (single output problem), or a list of arrays of\n        class labels (multi-output problem).\n\n    n_classes_ : int or list\n        The number of classes (single output problem), or a list containing the\n        number of classes for each output (multi-output problem).\n\n    feature_importances_ : array of shape = [n_features]\n        The feature importances (the higher, the more important the feature).\n\n    n_features_ : int\n        The number of features when ``fit`` is performed.\n\n    n_outputs_ : int\n        The number of outputs when ``fit`` is performed.\n\n    oob_score_ : float\n        Score of the training dataset obtained using an out-of-bag estimate.\n\n    oob_decision_function_ : array of shape = [n_samples, n_classes]\n        Decision function computed with out-of-bag estimate on the training\n        set. If n_estimators is small it might be possible that a data point\n        was never left out during the bootstrap. In this case,\n        `oob_decision_function_` might contain NaN.\n\n    Notes\n    -----\n    The default values for the parameters controlling the size of the trees\n    (e.g. ``max_depth``, ``min_samples_leaf``, etc.) lead to fully grown and\n    unpruned trees which can potentially be very large on some data sets. To\n    reduce memory consumption, the complexity and size of the trees should be\n    controlled by setting those parameter values.\n\n    References\n    ----------\n\n    .. [1] P. Geurts, D. Ernst., and L. Wehenkel, \"Extremely randomized \n           trees\", Machine Learning, 63(1), 3-42, 2006.\n\n    See also\n    --------\n    sklearn.tree.ExtraTreeClassifier : Base classifier for this ensemble.\n    RandomForestClassifier : Ensemble Classifier based on trees with optimal\n        splits.\n    "
        },
        {
            "classifier": "sklearn.ensemble.GradientBoostingClassifier",
            "name": "Gradient Boosting Classifier",
            "default_values": [
                {
                    "key": "criterion",
                    "value": "friedman_mse",
                    "type_": "str"
                },
                {
                    "key": "learning_rate",
                    "value": 0.1,
                    "type_": "float"
                },
                {
                    "key": "loss",
                    "value": "deviance",
                    "type_": "str"
                },
                {
                    "key": "max_depth",
                    "value": 3,
                    "type_": "int"
                },
                {
                    "key": "min_impurity_decrease",
                    "value": 0.0,
                    "type_": "float"
                },
                {
                    "key": "min_samples_leaf",
                    "value": 1,
                    "type_": "int"
                },
                {
                    "key": "min_samples_split",
                    "value": 2,
                    "type_": "int"
                },
                {
                    "key": "min_weight_fraction_leaf",
                    "value": 0.0,
                    "type_": "float"
                },
                {
                    "key": "n_estimators",
                    "value": 100,
                    "type_": "int"
                },
                {
                    "key": "presort",
                    "value": "auto",
                    "type_": "str"
                },
                {
                    "key": "subsample",
                    "value": 1.0,
                    "type_": "float"
                },
                {
                    "key": "tol",
                    "value": 0.0001,
                    "type_": "float"
                },
                {
                    "key": "validation_fraction",
                    "value": 0.1,
                    "type_": "float"
                },
                {
                    "key": "verbose",
                    "value": 0,
                    "type_": "int"
                },
                {
                    "key": "warm_start",
                    "value": false,
                    "type_": "bool"
                }
            ],
            "doc_string": "Gradient Boosting for classification.\n\n    GB builds an additive model in a\n    forward stage-wise fashion; it allows for the optimization of\n    arbitrary differentiable loss functions. In each stage ``n_classes_``\n    regression trees are fit on the negative gradient of the\n    binomial or multinomial deviance loss function. Binary classification\n    is a special case where only a single regression tree is induced.\n\n    Read more in the :ref:`User Guide <gradient_boosting>`.\n\n    Parameters\n    ----------\n    loss : {'deviance', 'exponential'}, optional (default='deviance')\n        loss function to be optimized. 'deviance' refers to\n        deviance (= logistic regression) for classification\n        with probabilistic outputs. For loss 'exponential' gradient\n        boosting recovers the AdaBoost algorithm.\n\n    learning_rate : float, optional (default=0.1)\n        learning rate shrinks the contribution of each tree by `learning_rate`.\n        There is a trade-off between learning_rate and n_estimators.\n\n    n_estimators : int (default=100)\n        The number of boosting stages to perform. Gradient boosting\n        is fairly robust to over-fitting so a large number usually\n        results in better performance.\n\n    subsample : float, optional (default=1.0)\n        The fraction of samples to be used for fitting the individual base\n        learners. If smaller than 1.0 this results in Stochastic Gradient\n        Boosting. `subsample` interacts with the parameter `n_estimators`.\n        Choosing `subsample < 1.0` leads to a reduction of variance\n        and an increase in bias.\n\n    criterion : string, optional (default=\"friedman_mse\")\n        The function to measure the quality of a split. Supported criteria\n        are \"friedman_mse\" for the mean squared error with improvement\n        score by Friedman, \"mse\" for mean squared error, and \"mae\" for\n        the mean absolute error. The default value of \"friedman_mse\" is\n        generally the best as it can provide a better approximation in\n        some cases.\n\n        .. versionadded:: 0.18\n\n    min_samples_split : int, float, optional (default=2)\n        The minimum number of samples required to split an internal node:\n\n        - If int, then consider `min_samples_split` as the minimum number.\n        - If float, then `min_samples_split` is a fraction and\n          `ceil(min_samples_split * n_samples)` are the minimum\n          number of samples for each split.\n\n        .. versionchanged:: 0.18\n           Added float values for fractions.\n\n    min_samples_leaf : int, float, optional (default=1)\n        The minimum number of samples required to be at a leaf node.\n        A split point at any depth will only be considered if it leaves at\n        least ``min_samples_leaf`` training samples in each of the left and\n        right branches.  This may have the effect of smoothing the model,\n        especially in regression.\n\n        - If int, then consider `min_samples_leaf` as the minimum number.\n        - If float, then `min_samples_leaf` is a fraction and\n          `ceil(min_samples_leaf * n_samples)` are the minimum\n          number of samples for each node.\n\n        .. versionchanged:: 0.18\n           Added float values for fractions.\n\n    min_weight_fraction_leaf : float, optional (default=0.)\n        The minimum weighted fraction of the sum total of weights (of all\n        the input samples) required to be at a leaf node. Samples have\n        equal weight when sample_weight is not provided.\n\n    max_depth : integer, optional (default=3)\n        maximum depth of the individual regression estimators. The maximum\n        depth limits the number of nodes in the tree. Tune this parameter\n        for best performance; the best value depends on the interaction\n        of the input variables.\n\n    min_impurity_decrease : float, optional (default=0.)\n        A node will be split if this split induces a decrease of the impurity\n        greater than or equal to this value.\n\n        The weighted impurity decrease equation is the following::\n\n            N_t / N * (impurity - N_t_R / N_t * right_impurity\n                                - N_t_L / N_t * left_impurity)\n\n        where ``N`` is the total number of samples, ``N_t`` is the number of\n        samples at the current node, ``N_t_L`` is the number of samples in the\n        left child, and ``N_t_R`` is the number of samples in the right child.\n\n        ``N``, ``N_t``, ``N_t_R`` and ``N_t_L`` all refer to the weighted sum,\n        if ``sample_weight`` is passed.\n\n        .. versionadded:: 0.19\n\n    min_impurity_split : float,\n        Threshold for early stopping in tree growth. A node will split\n        if its impurity is above the threshold, otherwise it is a leaf.\n\n        .. deprecated:: 0.19\n           ``min_impurity_split`` has been deprecated in favor of\n           ``min_impurity_decrease`` in 0.19 and will be removed in 0.21.\n           Use ``min_impurity_decrease`` instead.\n\n    init : estimator, optional\n        An estimator object that is used to compute the initial\n        predictions. ``init`` has to provide ``fit`` and ``predict``.\n        If None it uses ``loss.init_estimator``.\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    max_features : int, float, string or None, optional (default=None)\n        The number of features to consider when looking for the best split:\n\n        - If int, then consider `max_features` features at each split.\n        - If float, then `max_features` is a fraction and\n          `int(max_features * n_features)` features are considered at each\n          split.\n        - If \"auto\", then `max_features=sqrt(n_features)`.\n        - If \"sqrt\", then `max_features=sqrt(n_features)`.\n        - If \"log2\", then `max_features=log2(n_features)`.\n        - If None, then `max_features=n_features`.\n\n        Choosing `max_features < n_features` leads to a reduction of variance\n        and an increase in bias.\n\n        Note: the search for a split does not stop until at least one\n        valid partition of the node samples is found, even if it requires to\n        effectively inspect more than ``max_features`` features.\n\n    verbose : int, default: 0\n        Enable verbose output. If 1 then it prints progress and performance\n        once in a while (the more trees the lower the frequency). If greater\n        than 1 then it prints progress and performance for every tree.\n\n    max_leaf_nodes : int or None, optional (default=None)\n        Grow trees with ``max_leaf_nodes`` in best-first fashion.\n        Best nodes are defined as relative reduction in impurity.\n        If None then unlimited number of leaf nodes.\n\n    warm_start : bool, default: False\n        When set to ``True``, reuse the solution of the previous call to fit\n        and add more estimators to the ensemble, otherwise, just erase the\n        previous solution. See :term:`the Glossary <warm_start>`.\n\n    presort : bool or 'auto', optional (default='auto')\n        Whether to presort the data to speed up the finding of best splits in\n        fitting. Auto mode by default will use presorting on dense data and\n        default to normal sorting on sparse data. Setting presort to true on\n        sparse data will raise an error.\n\n        .. versionadded:: 0.17\n           *presort* parameter.\n\n    validation_fraction : float, optional, default 0.1\n        The proportion of training data to set aside as validation set for\n        early stopping. Must be between 0 and 1.\n        Only used if ``n_iter_no_change`` is set to an integer.\n\n        .. versionadded:: 0.20\n\n    n_iter_no_change : int, default None\n        ``n_iter_no_change`` is used to decide if early stopping will be used\n        to terminate training when validation score is not improving. By\n        default it is set to None to disable early stopping. If set to a\n        number, it will set aside ``validation_fraction`` size of the training\n        data as validation and terminate training when validation score is not\n        improving in all of the previous ``n_iter_no_change`` numbers of\n        iterations.\n\n        .. versionadded:: 0.20\n\n    tol : float, optional, default 1e-4\n        Tolerance for the early stopping. When the loss is not improving\n        by at least tol for ``n_iter_no_change`` iterations (if set to a\n        number), the training stops.\n\n        .. versionadded:: 0.20\n\n    Attributes\n    ----------\n    n_estimators_ : int\n        The number of estimators as selected by early stopping (if\n        ``n_iter_no_change`` is specified). Otherwise it is set to\n        ``n_estimators``.\n\n        .. versionadded:: 0.20\n\n    feature_importances_ : array, shape (n_features,)\n        The feature importances (the higher, the more important the feature).\n\n    oob_improvement_ : array, shape (n_estimators,)\n        The improvement in loss (= deviance) on the out-of-bag samples\n        relative to the previous iteration.\n        ``oob_improvement_[0]`` is the improvement in\n        loss of the first stage over the ``init`` estimator.\n\n    train_score_ : array, shape (n_estimators,)\n        The i-th score ``train_score_[i]`` is the deviance (= loss) of the\n        model at iteration ``i`` on the in-bag sample.\n        If ``subsample == 1`` this is the deviance on the training data.\n\n    loss_ : LossFunction\n        The concrete ``LossFunction`` object.\n\n    init_ : estimator\n        The estimator that provides the initial predictions.\n        Set via the ``init`` argument or ``loss.init_estimator``.\n\n    estimators_ : ndarray of DecisionTreeRegressor,shape (n_estimators, ``loss_.K``)\n        The collection of fitted sub-estimators. ``loss_.K`` is 1 for binary\n        classification, otherwise n_classes.\n\n    Notes\n    -----\n    The features are always randomly permuted at each split. Therefore,\n    the best found split may vary, even with the same training data and\n    ``max_features=n_features``, if the improvement of the criterion is\n    identical for several splits enumerated during the search of the best\n    split. To obtain a deterministic behaviour during fitting,\n    ``random_state`` has to be fixed.\n\n    See also\n    --------\n    sklearn.tree.DecisionTreeClassifier, RandomForestClassifier\n    AdaBoostClassifier\n\n    References\n    ----------\n    J. Friedman, Greedy Function Approximation: A Gradient Boosting\n    Machine, The Annals of Statistics, Vol. 29, No. 5, 2001.\n\n    J. Friedman, Stochastic Gradient Boosting, 1999\n\n    T. Hastie, R. Tibshirani and J. Friedman.\n    Elements of Statistical Learning Ed. 2, Springer, 2009.\n    "
        },
        {
            "classifier": "sklearn.ensemble.RandomForestClassifier",
            "name": "Random Forest Classifier",
            "default_values": [
                {
                    "key": "bootstrap",
                    "value": true,
                    "type_": "bool"
                },
                {
                    "key": "criterion",
                    "value": "gini",
                    "type_": "str"
                },
                {
                    "key": "max_features",
                    "value": "auto",
                    "type_": "str"
                },
                {
                    "key": "min_impurity_decrease",
                    "value": 0.0,
                    "type_": "float"
                },
                {
                    "key": "min_samples_leaf",
                    "value": 1,
                    "type_": "int"
                },
                {
                    "key": "min_samples_split",
                    "value": 2,
                    "type_": "int"
                },
                {
                    "key": "min_weight_fraction_leaf",
                    "value": 0.0,
                    "type_": "float"
                },
                {
                    "key": "n_estimators",
                    "value": "warn",
                    "type_": "str"
                },
                {
                    "key": "oob_score",
                    "value": false,
                    "type_": "bool"
                },
                {
                    "key": "verbose",
                    "value": 0,
                    "type_": "int"
                },
                {
                    "key": "warm_start",
                    "value": false,
                    "type_": "bool"
                }
            ],
            "doc_string": "A random forest classifier.\n\n    A random forest is a meta estimator that fits a number of decision tree\n    classifiers on various sub-samples of the dataset and uses averaging to\n    improve the predictive accuracy and control over-fitting.\n    The sub-sample size is always the same as the original\n    input sample size but the samples are drawn with replacement if\n    `bootstrap=True` (default).\n\n    Read more in the :ref:`User Guide <forest>`.\n\n    Parameters\n    ----------\n    n_estimators : integer, optional (default=10)\n        The number of trees in the forest.\n\n        .. versionchanged:: 0.20\n           The default value of ``n_estimators`` will change from 10 in\n           version 0.20 to 100 in version 0.22.\n\n    criterion : string, optional (default=\"gini\")\n        The function to measure the quality of a split. Supported criteria are\n        \"gini\" for the Gini impurity and \"entropy\" for the information gain.\n        Note: this parameter is tree-specific.\n\n    max_depth : integer or None, optional (default=None)\n        The maximum depth of the tree. If None, then nodes are expanded until\n        all leaves are pure or until all leaves contain less than\n        min_samples_split samples.\n\n    min_samples_split : int, float, optional (default=2)\n        The minimum number of samples required to split an internal node:\n\n        - If int, then consider `min_samples_split` as the minimum number.\n        - If float, then `min_samples_split` is a fraction and\n          `ceil(min_samples_split * n_samples)` are the minimum\n          number of samples for each split.\n\n        .. versionchanged:: 0.18\n           Added float values for fractions.\n\n    min_samples_leaf : int, float, optional (default=1)\n        The minimum number of samples required to be at a leaf node.\n        A split point at any depth will only be considered if it leaves at\n        least ``min_samples_leaf`` training samples in each of the left and\n        right branches.  This may have the effect of smoothing the model,\n        especially in regression.\n\n        - If int, then consider `min_samples_leaf` as the minimum number.\n        - If float, then `min_samples_leaf` is a fraction and\n          `ceil(min_samples_leaf * n_samples)` are the minimum\n          number of samples for each node.\n\n        .. versionchanged:: 0.18\n           Added float values for fractions.\n\n    min_weight_fraction_leaf : float, optional (default=0.)\n        The minimum weighted fraction of the sum total of weights (of all\n        the input samples) required to be at a leaf node. Samples have\n        equal weight when sample_weight is not provided.\n\n    max_features : int, float, string or None, optional (default=\"auto\")\n        The number of features to consider when looking for the best split:\n\n        - If int, then consider `max_features` features at each split.\n        - If float, then `max_features` is a fraction and\n          `int(max_features * n_features)` features are considered at each\n          split.\n        - If \"auto\", then `max_features=sqrt(n_features)`.\n        - If \"sqrt\", then `max_features=sqrt(n_features)` (same as \"auto\").\n        - If \"log2\", then `max_features=log2(n_features)`.\n        - If None, then `max_features=n_features`.\n\n        Note: the search for a split does not stop until at least one\n        valid partition of the node samples is found, even if it requires to\n        effectively inspect more than ``max_features`` features.\n\n    max_leaf_nodes : int or None, optional (default=None)\n        Grow trees with ``max_leaf_nodes`` in best-first fashion.\n        Best nodes are defined as relative reduction in impurity.\n        If None then unlimited number of leaf nodes.\n\n    min_impurity_decrease : float, optional (default=0.)\n        A node will be split if this split induces a decrease of the impurity\n        greater than or equal to this value.\n\n        The weighted impurity decrease equation is the following::\n\n            N_t / N * (impurity - N_t_R / N_t * right_impurity\n                                - N_t_L / N_t * left_impurity)\n\n        where ``N`` is the total number of samples, ``N_t`` is the number of\n        samples at the current node, ``N_t_L`` is the number of samples in the\n        left child, and ``N_t_R`` is the number of samples in the right child.\n\n        ``N``, ``N_t``, ``N_t_R`` and ``N_t_L`` all refer to the weighted sum,\n        if ``sample_weight`` is passed.\n\n        .. versionadded:: 0.19\n\n    min_impurity_split : float,\n        Threshold for early stopping in tree growth. A node will split\n        if its impurity is above the threshold, otherwise it is a leaf.\n\n        .. deprecated:: 0.19\n           ``min_impurity_split`` has been deprecated in favor of\n           ``min_impurity_decrease`` in 0.19 and will be removed in 0.21.\n           Use ``min_impurity_decrease`` instead.\n\n    bootstrap : boolean, optional (default=True)\n        Whether bootstrap samples are used when building trees.\n\n    oob_score : bool (default=False)\n        Whether to use out-of-bag samples to estimate\n        the generalization accuracy.\n\n    n_jobs : int or None, optional (default=None)\n        The number of jobs to run in parallel for both `fit` and `predict`.\n        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n        ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n        for more details.\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    verbose : int, optional (default=0)\n        Controls the verbosity when fitting and predicting.\n\n    warm_start : bool, optional (default=False)\n        When set to ``True``, reuse the solution of the previous call to fit\n        and add more estimators to the ensemble, otherwise, just fit a whole\n        new forest. See :term:`the Glossary <warm_start>`.\n\n    class_weight : dict, list of dicts, \"balanced\", \"balanced_subsample\" or     None, optional (default=None)\n        Weights associated with classes in the form ``{class_label: weight}``.\n        If not given, all classes are supposed to have weight one. For\n        multi-output problems, a list of dicts can be provided in the same\n        order as the columns of y.\n\n        Note that for multioutput (including multilabel) weights should be\n        defined for each class of every column in its own dict. For example,\n        for four-class multilabel classification weights should be\n        [{0: 1, 1: 1}, {0: 1, 1: 5}, {0: 1, 1: 1}, {0: 1, 1: 1}] instead of\n        [{1:1}, {2:5}, {3:1}, {4:1}].\n\n        The \"balanced\" mode uses the values of y to automatically adjust\n        weights inversely proportional to class frequencies in the input data\n        as ``n_samples / (n_classes * np.bincount(y))``\n\n        The \"balanced_subsample\" mode is the same as \"balanced\" except that\n        weights are computed based on the bootstrap sample for every tree\n        grown.\n\n        For multi-output, the weights of each column of y will be multiplied.\n\n        Note that these weights will be multiplied with sample_weight (passed\n        through the fit method) if sample_weight is specified.\n\n    Attributes\n    ----------\n    estimators_ : list of DecisionTreeClassifier\n        The collection of fitted sub-estimators.\n\n    classes_ : array of shape = [n_classes] or a list of such arrays\n        The classes labels (single output problem), or a list of arrays of\n        class labels (multi-output problem).\n\n    n_classes_ : int or list\n        The number of classes (single output problem), or a list containing the\n        number of classes for each output (multi-output problem).\n\n    n_features_ : int\n        The number of features when ``fit`` is performed.\n\n    n_outputs_ : int\n        The number of outputs when ``fit`` is performed.\n\n    feature_importances_ : array of shape = [n_features]\n        The feature importances (the higher, the more important the feature).\n\n    oob_score_ : float\n        Score of the training dataset obtained using an out-of-bag estimate.\n\n    oob_decision_function_ : array of shape = [n_samples, n_classes]\n        Decision function computed with out-of-bag estimate on the training\n        set. If n_estimators is small it might be possible that a data point\n        was never left out during the bootstrap. In this case,\n        `oob_decision_function_` might contain NaN.\n\n    Examples\n    --------\n    >>> from sklearn.ensemble import RandomForestClassifier\n    >>> from sklearn.datasets import make_classification\n    >>>\n    >>> X, y = make_classification(n_samples=1000, n_features=4,\n    ...                            n_informative=2, n_redundant=0,\n    ...                            random_state=0, shuffle=False)\n    >>> clf = RandomForestClassifier(n_estimators=100, max_depth=2,\n    ...                              random_state=0)\n    >>> clf.fit(X, y)\n    RandomForestClassifier(bootstrap=True, class_weight=None, criterion='gini',\n                max_depth=2, max_features='auto', max_leaf_nodes=None,\n                min_impurity_decrease=0.0, min_impurity_split=None,\n                min_samples_leaf=1, min_samples_split=2,\n                min_weight_fraction_leaf=0.0, n_estimators=100, n_jobs=None,\n                oob_score=False, random_state=0, verbose=0, warm_start=False)\n    >>> print(clf.feature_importances_)\n    [0.14205973 0.76664038 0.0282433  0.06305659]\n    >>> print(clf.predict([[0, 0, 0, 0]]))\n    [1]\n\n    Notes\n    -----\n    The default values for the parameters controlling the size of the trees\n    (e.g. ``max_depth``, ``min_samples_leaf``, etc.) lead to fully grown and\n    unpruned trees which can potentially be very large on some data sets. To\n    reduce memory consumption, the complexity and size of the trees should be\n    controlled by setting those parameter values.\n\n    The features are always randomly permuted at each split. Therefore,\n    the best found split may vary, even with the same training data,\n    ``max_features=n_features`` and ``bootstrap=False``, if the improvement\n    of the criterion is identical for several splits enumerated during the\n    search of the best split. To obtain a deterministic behaviour during\n    fitting, ``random_state`` has to be fixed.\n\n    References\n    ----------\n\n    .. [1] L. Breiman, \"Random Forests\", Machine Learning, 45(1), 5-32, 2001.\n\n    See also\n    --------\n    DecisionTreeClassifier, ExtraTreesClassifier\n    "
        },
        {
            "classifier": "sklearn.linear_model.LogisticRegression",
            "name": "Logistic Regression",
            "default_values": [
                {
                    "key": "C",
                    "value": 1.0,
                    "type_": "float"
                },
                {
                    "key": "dual",
                    "value": false,
                    "type_": "bool"
                },
                {
                    "key": "fit_intercept",
                    "value": true,
                    "type_": "bool"
                },
                {
                    "key": "intercept_scaling",
                    "value": 1,
                    "type_": "int"
                },
                {
                    "key": "max_iter",
                    "value": 100,
                    "type_": "int"
                },
                {
                    "key": "multi_class",
                    "value": "warn",
                    "type_": "str"
                },
                {
                    "key": "penalty",
                    "value": "l2",
                    "type_": "str"
                },
                {
                    "key": "solver",
                    "value": "warn",
                    "type_": "str"
                },
                {
                    "key": "tol",
                    "value": 0.0001,
                    "type_": "float"
                },
                {
                    "key": "verbose",
                    "value": 0,
                    "type_": "int"
                },
                {
                    "key": "warm_start",
                    "value": false,
                    "type_": "bool"
                }
            ],
            "doc_string": "Logistic Regression (aka logit, MaxEnt) classifier.\n\n    In the multiclass case, the training algorithm uses the one-vs-rest (OvR)\n    scheme if the 'multi_class' option is set to 'ovr', and uses the cross-\n    entropy loss if the 'multi_class' option is set to 'multinomial'.\n    (Currently the 'multinomial' option is supported only by the 'lbfgs',\n    'sag' and 'newton-cg' solvers.)\n\n    This class implements regularized logistic regression using the\n    'liblinear' library, 'newton-cg', 'sag' and 'lbfgs' solvers. It can handle\n    both dense and sparse input. Use C-ordered arrays or CSR matrices\n    containing 64-bit floats for optimal performance; any other input format\n    will be converted (and copied).\n\n    The 'newton-cg', 'sag', and 'lbfgs' solvers support only L2 regularization\n    with primal formulation. The 'liblinear' solver supports both L1 and L2\n    regularization, with a dual formulation only for the L2 penalty.\n\n    Read more in the :ref:`User Guide <logistic_regression>`.\n\n    Parameters\n    ----------\n    penalty : str, 'l1' or 'l2', default: 'l2'\n        Used to specify the norm used in the penalization. The 'newton-cg',\n        'sag' and 'lbfgs' solvers support only l2 penalties.\n\n        .. versionadded:: 0.19\n           l1 penalty with SAGA solver (allowing 'multinomial' + L1)\n\n    dual : bool, default: False\n        Dual or primal formulation. Dual formulation is only implemented for\n        l2 penalty with liblinear solver. Prefer dual=False when\n        n_samples > n_features.\n\n    tol : float, default: 1e-4\n        Tolerance for stopping criteria.\n\n    C : float, default: 1.0\n        Inverse of regularization strength; must be a positive float.\n        Like in support vector machines, smaller values specify stronger\n        regularization.\n\n    fit_intercept : bool, default: True\n        Specifies if a constant (a.k.a. bias or intercept) should be\n        added to the decision function.\n\n    intercept_scaling : float, default 1.\n        Useful only when the solver 'liblinear' is used\n        and self.fit_intercept is set to True. In this case, x becomes\n        [x, self.intercept_scaling],\n        i.e. a \"synthetic\" feature with constant value equal to\n        intercept_scaling is appended to the instance vector.\n        The intercept becomes ``intercept_scaling * synthetic_feature_weight``.\n\n        Note! the synthetic feature weight is subject to l1/l2 regularization\n        as all other features.\n        To lessen the effect of regularization on synthetic feature weight\n        (and therefore on the intercept) intercept_scaling has to be increased.\n\n    class_weight : dict or 'balanced', default: None\n        Weights associated with classes in the form ``{class_label: weight}``.\n        If not given, all classes are supposed to have weight one.\n\n        The \"balanced\" mode uses the values of y to automatically adjust\n        weights inversely proportional to class frequencies in the input data\n        as ``n_samples / (n_classes * np.bincount(y))``.\n\n        Note that these weights will be multiplied with sample_weight (passed\n        through the fit method) if sample_weight is specified.\n\n        .. versionadded:: 0.17\n           *class_weight='balanced'*\n\n    random_state : int, RandomState instance or None, optional, default: None\n        The seed of the pseudo random number generator to use when shuffling\n        the data.  If int, random_state is the seed used by the random number\n        generator; If RandomState instance, random_state is the random number\n        generator; If None, the random number generator is the RandomState\n        instance used by `np.random`. Used when ``solver`` == 'sag' or\n        'liblinear'.\n\n    solver : str, {'newton-cg', 'lbfgs', 'liblinear', 'sag', 'saga'},              default: 'liblinear'.\n\n        Algorithm to use in the optimization problem.\n\n        - For small datasets, 'liblinear' is a good choice, whereas 'sag' and\n          'saga' are faster for large ones.\n        - For multiclass problems, only 'newton-cg', 'sag', 'saga' and 'lbfgs'\n          handle multinomial loss; 'liblinear' is limited to one-versus-rest\n          schemes.\n        - 'newton-cg', 'lbfgs' and 'sag' only handle L2 penalty, whereas\n          'liblinear' and 'saga' handle L1 penalty.\n\n        Note that 'sag' and 'saga' fast convergence is only guaranteed on\n        features with approximately the same scale. You can\n        preprocess the data with a scaler from sklearn.preprocessing.\n\n        .. versionadded:: 0.17\n           Stochastic Average Gradient descent solver.\n        .. versionadded:: 0.19\n           SAGA solver.\n        .. versionchanged:: 0.20\n            Default will change from 'liblinear' to 'lbfgs' in 0.22.\n\n    max_iter : int, default: 100\n        Useful only for the newton-cg, sag and lbfgs solvers.\n        Maximum number of iterations taken for the solvers to converge.\n\n    multi_class : str, {'ovr', 'multinomial', 'auto'}, default: 'ovr'\n        If the option chosen is 'ovr', then a binary problem is fit for each\n        label. For 'multinomial' the loss minimised is the multinomial loss fit\n        across the entire probability distribution, *even when the data is\n        binary*. 'multinomial' is unavailable when solver='liblinear'.\n        'auto' selects 'ovr' if the data is binary, or if solver='liblinear',\n        and otherwise selects 'multinomial'.\n\n        .. versionadded:: 0.18\n           Stochastic Average Gradient descent solver for 'multinomial' case.\n        .. versionchanged:: 0.20\n            Default will change from 'ovr' to 'auto' in 0.22.\n\n    verbose : int, default: 0\n        For the liblinear and lbfgs solvers set verbose to any positive\n        number for verbosity.\n\n    warm_start : bool, default: False\n        When set to True, reuse the solution of the previous call to fit as\n        initialization, otherwise, just erase the previous solution.\n        Useless for liblinear solver. See :term:`the Glossary <warm_start>`.\n\n        .. versionadded:: 0.17\n           *warm_start* to support *lbfgs*, *newton-cg*, *sag*, *saga* solvers.\n\n    n_jobs : int or None, optional (default=None)\n        Number of CPU cores used when parallelizing over classes if\n        multi_class='ovr'\". This parameter is ignored when the ``solver`` is\n        set to 'liblinear' regardless of whether 'multi_class' is specified or\n        not. ``None`` means 1 unless in a :obj:`joblib.parallel_backend`\n        context. ``-1`` means using all processors.\n        See :term:`Glossary <n_jobs>` for more details.\n\n    Attributes\n    ----------\n\n    coef_ : array, shape (1, n_features) or (n_classes, n_features)\n        Coefficient of the features in the decision function.\n\n        `coef_` is of shape (1, n_features) when the given problem is binary.\n        In particular, when `multi_class='multinomial'`, `coef_` corresponds\n        to outcome 1 (True) and `-coef_` corresponds to outcome 0 (False).\n\n    intercept_ : array, shape (1,) or (n_classes,)\n        Intercept (a.k.a. bias) added to the decision function.\n\n        If `fit_intercept` is set to False, the intercept is set to zero.\n        `intercept_` is of shape (1,) when the given problem is binary.\n        In particular, when `multi_class='multinomial'`, `intercept_`\n        corresponds to outcome 1 (True) and `-intercept_` corresponds to\n        outcome 0 (False).\n\n    n_iter_ : array, shape (n_classes,) or (1, )\n        Actual number of iterations for all classes. If binary or multinomial,\n        it returns only 1 element. For liblinear solver, only the maximum\n        number of iteration across all classes is given.\n\n        .. versionchanged:: 0.20\n\n            In SciPy <= 1.0.0 the number of lbfgs iterations may exceed\n            ``max_iter``. ``n_iter_`` will now report at most ``max_iter``.\n\n    Examples\n    --------\n    >>> from sklearn.datasets import load_iris\n    >>> from sklearn.linear_model import LogisticRegression\n    >>> X, y = load_iris(return_X_y=True)\n    >>> clf = LogisticRegression(random_state=0, solver='lbfgs',\n    ...                          multi_class='multinomial').fit(X, y)\n    >>> clf.predict(X[:2, :])\n    array([0, 0])\n    >>> clf.predict_proba(X[:2, :]) # doctest: +ELLIPSIS\n    array([[9.8...e-01, 1.8...e-02, 1.4...e-08],\n           [9.7...e-01, 2.8...e-02, ...e-08]])\n    >>> clf.score(X, y)\n    0.97...\n\n    See also\n    --------\n    SGDClassifier : incrementally trained logistic regression (when given\n        the parameter ``loss=\"log\"``).\n    LogisticRegressionCV : Logistic regression with built-in cross validation\n\n    Notes\n    -----\n    The underlying C implementation uses a random number generator to\n    select features when fitting the model. It is thus not uncommon,\n    to have slightly different results for the same input data. If\n    that happens, try with a smaller tol parameter.\n\n    Predict output may not match that of standalone liblinear in certain\n    cases. See :ref:`differences from liblinear <liblinear_differences>`\n    in the narrative documentation.\n\n    References\n    ----------\n\n    LIBLINEAR -- A Library for Large Linear Classification\n        http://www.csie.ntu.edu.tw/~cjlin/liblinear/\n\n    SAG -- Mark Schmidt, Nicolas Le Roux, and Francis Bach\n        Minimizing Finite Sums with the Stochastic Average Gradient\n        https://hal.inria.fr/hal-00860051/document\n\n    SAGA -- Defazio, A., Bach F. & Lacoste-Julien S. (2014).\n        SAGA: A Fast Incremental Gradient Method With Support\n        for Non-Strongly Convex Composite Objectives\n        https://arxiv.org/abs/1407.0202\n\n    Hsiang-Fu Yu, Fang-Lan Huang, Chih-Jen Lin (2011). Dual coordinate descent\n        methods for logistic regression and maximum entropy models.\n        Machine Learning 85(1-2):41-75.\n        http://www.csie.ntu.edu.tw/~cjlin/papers/maxent_dual.pdf\n    "
        },
        {
            "classifier": "sklearn.linear_model.LogisticRegressionCV",
            "name": "Logistic Regression C V",
            "default_values": [
                {
                    "key": "Cs",
                    "value": 10,
                    "type_": "int"
                },
                {
                    "key": "cv",
                    "value": "warn",
                    "type_": "str"
                },
                {
                    "key": "dual",
                    "value": false,
                    "type_": "bool"
                },
                {
                    "key": "fit_intercept",
                    "value": true,
                    "type_": "bool"
                },
                {
                    "key": "intercept_scaling",
                    "value": 1.0,
                    "type_": "float"
                },
                {
                    "key": "max_iter",
                    "value": 100,
                    "type_": "int"
                },
                {
                    "key": "multi_class",
                    "value": "warn",
                    "type_": "str"
                },
                {
                    "key": "penalty",
                    "value": "l2",
                    "type_": "str"
                },
                {
                    "key": "refit",
                    "value": true,
                    "type_": "bool"
                },
                {
                    "key": "solver",
                    "value": "lbfgs",
                    "type_": "str"
                },
                {
                    "key": "tol",
                    "value": 0.0001,
                    "type_": "float"
                },
                {
                    "key": "verbose",
                    "value": 0,
                    "type_": "int"
                }
            ],
            "doc_string": "Logistic Regression CV (aka logit, MaxEnt) classifier.\n\n    This class implements logistic regression using liblinear, newton-cg, sag\n    of lbfgs optimizer. The newton-cg, sag and lbfgs solvers support only L2\n    regularization with primal formulation. The liblinear solver supports both\n    L1 and L2 regularization, with a dual formulation only for the L2 penalty.\n\n    For the grid of Cs values (that are set by default to be ten values in\n    a logarithmic scale between 1e-4 and 1e4), the best hyperparameter is\n    selected by the cross-validator StratifiedKFold, but it can be changed\n    using the cv parameter. In the case of newton-cg and lbfgs solvers,\n    we warm start along the path i.e guess the initial coefficients of the\n    present fit to be the coefficients got after convergence in the previous\n    fit, so it is supposed to be faster for high-dimensional dense data.\n\n    For a multiclass problem, the hyperparameters for each class are computed\n    using the best scores got by doing a one-vs-rest in parallel across all\n    folds and classes. Hence this is not the true multinomial loss.\n\n    Read more in the :ref:`User Guide <logistic_regression>`.\n\n    Parameters\n    ----------\n    Cs : list of floats | int\n        Each of the values in Cs describes the inverse of regularization\n        strength. If Cs is as an int, then a grid of Cs values are chosen\n        in a logarithmic scale between 1e-4 and 1e4.\n        Like in support vector machines, smaller values specify stronger\n        regularization.\n\n    fit_intercept : bool, default: True\n        Specifies if a constant (a.k.a. bias or intercept) should be\n        added to the decision function.\n\n    cv : integer or cross-validation generator, default: None\n        The default cross-validation generator used is Stratified K-Folds.\n        If an integer is provided, then it is the number of folds used.\n        See the module :mod:`sklearn.model_selection` module for the\n        list of possible cross-validation objects.\n\n        .. versionchanged:: 0.20\n            ``cv`` default value if None will change from 3-fold to 5-fold\n            in v0.22.\n\n    dual : bool\n        Dual or primal formulation. Dual formulation is only implemented for\n        l2 penalty with liblinear solver. Prefer dual=False when\n        n_samples > n_features.\n\n    penalty : str, 'l1' or 'l2'\n        Used to specify the norm used in the penalization. The 'newton-cg',\n        'sag' and 'lbfgs' solvers support only l2 penalties.\n\n    scoring : string, callable, or None\n        A string (see model evaluation documentation) or\n        a scorer callable object / function with signature\n        ``scorer(estimator, X, y)``. For a list of scoring functions\n        that can be used, look at :mod:`sklearn.metrics`. The\n        default scoring option used is 'accuracy'.\n\n    solver : str, {'newton-cg', 'lbfgs', 'liblinear', 'sag', 'saga'},              default: 'lbfgs'.\n\n        Algorithm to use in the optimization problem.\n\n        - For small datasets, 'liblinear' is a good choice, whereas 'sag' and\n          'saga' are faster for large ones.\n        - For multiclass problems, only 'newton-cg', 'sag', 'saga' and 'lbfgs'\n          handle multinomial loss; 'liblinear' is limited to one-versus-rest\n          schemes.\n        - 'newton-cg', 'lbfgs' and 'sag' only handle L2 penalty, whereas\n          'liblinear' and 'saga' handle L1 penalty.\n        - 'liblinear' might be slower in LogisticRegressionCV because it does\n          not handle warm-starting.\n\n        Note that 'sag' and 'saga' fast convergence is only guaranteed on\n        features with approximately the same scale. You can preprocess the data\n        with a scaler from sklearn.preprocessing.\n\n        .. versionadded:: 0.17\n           Stochastic Average Gradient descent solver.\n        .. versionadded:: 0.19\n           SAGA solver.\n\n    tol : float, optional\n        Tolerance for stopping criteria.\n\n    max_iter : int, optional\n        Maximum number of iterations of the optimization algorithm.\n\n    class_weight : dict or 'balanced', optional\n        Weights associated with classes in the form ``{class_label: weight}``.\n        If not given, all classes are supposed to have weight one.\n\n        The \"balanced\" mode uses the values of y to automatically adjust\n        weights inversely proportional to class frequencies in the input data\n        as ``n_samples / (n_classes * np.bincount(y))``.\n\n        Note that these weights will be multiplied with sample_weight (passed\n        through the fit method) if sample_weight is specified.\n\n        .. versionadded:: 0.17\n           class_weight == 'balanced'\n\n    n_jobs : int or None, optional (default=None)\n        Number of CPU cores used during the cross-validation loop.\n        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n        ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n        for more details.\n\n    verbose : int\n        For the 'liblinear', 'sag' and 'lbfgs' solvers set verbose to any\n        positive number for verbosity.\n\n    refit : bool\n        If set to True, the scores are averaged across all folds, and the\n        coefs and the C that corresponds to the best score is taken, and a\n        final refit is done using these parameters.\n        Otherwise the coefs, intercepts and C that correspond to the\n        best scores across folds are averaged.\n\n    intercept_scaling : float, default 1.\n        Useful only when the solver 'liblinear' is used\n        and self.fit_intercept is set to True. In this case, x becomes\n        [x, self.intercept_scaling],\n        i.e. a \"synthetic\" feature with constant value equal to\n        intercept_scaling is appended to the instance vector.\n        The intercept becomes ``intercept_scaling * synthetic_feature_weight``.\n\n        Note! the synthetic feature weight is subject to l1/l2 regularization\n        as all other features.\n        To lessen the effect of regularization on synthetic feature weight\n        (and therefore on the intercept) intercept_scaling has to be increased.\n\n    multi_class : str, {'ovr', 'multinomial', 'auto'}, default: 'ovr'\n        If the option chosen is 'ovr', then a binary problem is fit for each\n        label. For 'multinomial' the loss minimised is the multinomial loss fit\n        across the entire probability distribution, *even when the data is\n        binary*. 'multinomial' is unavailable when solver='liblinear'.\n        'auto' selects 'ovr' if the data is binary, or if solver='liblinear',\n        and otherwise selects 'multinomial'.\n\n        .. versionadded:: 0.18\n           Stochastic Average Gradient descent solver for 'multinomial' case.\n        .. versionchanged:: 0.20\n            Default will change from 'ovr' to 'auto' in 0.22.\n\n    random_state : int, RandomState instance or None, optional, default None\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    Attributes\n    ----------\n    coef_ : array, shape (1, n_features) or (n_classes, n_features)\n        Coefficient of the features in the decision function.\n\n        `coef_` is of shape (1, n_features) when the given problem\n        is binary.\n\n    intercept_ : array, shape (1,) or (n_classes,)\n        Intercept (a.k.a. bias) added to the decision function.\n\n        If `fit_intercept` is set to False, the intercept is set to zero.\n        `intercept_` is of shape(1,) when the problem is binary.\n\n    Cs_ : array\n        Array of C i.e. inverse of regularization parameter values used\n        for cross-validation.\n\n    coefs_paths_ : array, shape ``(n_folds, len(Cs_), n_features)`` or                    ``(n_folds, len(Cs_), n_features + 1)``\n        dict with classes as the keys, and the path of coefficients obtained\n        during cross-validating across each fold and then across each Cs\n        after doing an OvR for the corresponding class as values.\n        If the 'multi_class' option is set to 'multinomial', then\n        the coefs_paths are the coefficients corresponding to each class.\n        Each dict value has shape ``(n_folds, len(Cs_), n_features)`` or\n        ``(n_folds, len(Cs_), n_features + 1)`` depending on whether the\n        intercept is fit or not.\n\n    scores_ : dict\n        dict with classes as the keys, and the values as the\n        grid of scores obtained during cross-validating each fold, after doing\n        an OvR for the corresponding class. If the 'multi_class' option\n        given is 'multinomial' then the same scores are repeated across\n        all classes, since this is the multinomial class.\n        Each dict value has shape (n_folds, len(Cs))\n\n    C_ : array, shape (n_classes,) or (n_classes - 1,)\n        Array of C that maps to the best scores across every class. If refit is\n        set to False, then for each class, the best C is the average of the\n        C's that correspond to the best scores for each fold.\n        `C_` is of shape(n_classes,) when the problem is binary.\n\n    n_iter_ : array, shape (n_classes, n_folds, n_cs) or (1, n_folds, n_cs)\n        Actual number of iterations for all classes, folds and Cs.\n        In the binary or multinomial cases, the first dimension is equal to 1.\n\n    Examples\n    --------\n    >>> from sklearn.datasets import load_iris\n    >>> from sklearn.linear_model import LogisticRegressionCV\n    >>> X, y = load_iris(return_X_y=True)\n    >>> clf = LogisticRegressionCV(cv=5, random_state=0,\n    ...                            multi_class='multinomial').fit(X, y)\n    >>> clf.predict(X[:2, :])\n    array([0, 0])\n    >>> clf.predict_proba(X[:2, :]).shape\n    (2, 3)\n    >>> clf.score(X, y) # doctest: +ELLIPSIS\n    0.98...\n\n    See also\n    --------\n    LogisticRegression\n\n    "
        },
        {
            "classifier": "sklearn.linear_model.PassiveAggressiveClassifier",
            "name": "Passive Aggressive Classifier",
            "default_values": [
                {
                    "key": "C",
                    "value": 1.0,
                    "type_": "float"
                },
                {
                    "key": "average",
                    "value": false,
                    "type_": "bool"
                },
                {
                    "key": "early_stopping",
                    "value": false,
                    "type_": "bool"
                },
                {
                    "key": "fit_intercept",
                    "value": true,
                    "type_": "bool"
                },
                {
                    "key": "loss",
                    "value": "hinge",
                    "type_": "str"
                },
                {
                    "key": "n_iter_no_change",
                    "value": 5,
                    "type_": "int"
                },
                {
                    "key": "shuffle",
                    "value": true,
                    "type_": "bool"
                },
                {
                    "key": "validation_fraction",
                    "value": 0.1,
                    "type_": "float"
                },
                {
                    "key": "verbose",
                    "value": 0,
                    "type_": "int"
                },
                {
                    "key": "warm_start",
                    "value": false,
                    "type_": "bool"
                }
            ],
            "doc_string": "Passive Aggressive Classifier\n\n    Read more in the :ref:`User Guide <passive_aggressive>`.\n\n    Parameters\n    ----------\n\n    C : float\n        Maximum step size (regularization). Defaults to 1.0.\n\n    fit_intercept : bool, default=False\n        Whether the intercept should be estimated or not. If False, the\n        data is assumed to be already centered.\n\n    max_iter : int, optional\n        The maximum number of passes over the training data (aka epochs).\n        It only impacts the behavior in the ``fit`` method, and not the\n        `partial_fit`.\n        Defaults to 5. Defaults to 1000 from 0.21, or if tol is not None.\n\n        .. versionadded:: 0.19\n\n    tol : float or None, optional\n        The stopping criterion. If it is not None, the iterations will stop\n        when (loss > previous_loss - tol). Defaults to None.\n        Defaults to 1e-3 from 0.21.\n\n        .. versionadded:: 0.19\n\n    early_stopping : bool, default=False\n        Whether to use early stopping to terminate training when validation.\n        score is not improving. If set to True, it will automatically set aside\n        a fraction of training data as validation and terminate training when\n        validation score is not improving by at least tol for\n        n_iter_no_change consecutive epochs.\n\n        .. versionadded:: 0.20\n\n    validation_fraction : float, default=0.1\n        The proportion of training data to set aside as validation set for\n        early stopping. Must be between 0 and 1.\n        Only used if early_stopping is True.\n\n        .. versionadded:: 0.20\n\n    n_iter_no_change : int, default=5\n        Number of iterations with no improvement to wait before early stopping.\n\n        .. versionadded:: 0.20\n\n    shuffle : bool, default=True\n        Whether or not the training data should be shuffled after each epoch.\n\n    verbose : integer, optional\n        The verbosity level\n\n    loss : string, optional\n        The loss function to be used:\n        hinge: equivalent to PA-I in the reference paper.\n        squared_hinge: equivalent to PA-II in the reference paper.\n\n    n_jobs : int or None, optional (default=None)\n        The number of CPUs to use to do the OVA (One Versus All, for\n        multi-class problems) computation.\n        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n        ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n        for more details.\n\n    random_state : int, RandomState instance or None, optional, default=None\n        The seed of the pseudo random number generator to use when shuffling\n        the data.  If int, random_state is the seed used by the random number\n        generator; If RandomState instance, random_state is the random number\n        generator; If None, the random number generator is the RandomState\n        instance used by `np.random`.\n\n    warm_start : bool, optional\n        When set to True, reuse the solution of the previous call to fit as\n        initialization, otherwise, just erase the previous solution.\n        See :term:`the Glossary <warm_start>`.\n\n        Repeatedly calling fit or partial_fit when warm_start is True can\n        result in a different solution than when calling fit a single time\n        because of the way the data is shuffled.\n\n    class_weight : dict, {class_label: weight} or \"balanced\" or None, optional\n        Preset for the class_weight fit parameter.\n\n        Weights associated with classes. If not given, all classes\n        are supposed to have weight one.\n\n        The \"balanced\" mode uses the values of y to automatically adjust\n        weights inversely proportional to class frequencies in the input data\n        as ``n_samples / (n_classes * np.bincount(y))``\n\n        .. versionadded:: 0.17\n           parameter *class_weight* to automatically weight samples.\n\n    average : bool or int, optional\n        When set to True, computes the averaged SGD weights and stores the\n        result in the ``coef_`` attribute. If set to an int greater than 1,\n        averaging will begin once the total number of samples seen reaches\n        average. So average=10 will begin averaging after seeing 10 samples.\n\n        .. versionadded:: 0.19\n           parameter *average* to use weights averaging in SGD\n\n    n_iter : int, optional\n        The number of passes over the training data (aka epochs).\n        Defaults to None. Deprecated, will be removed in 0.21.\n\n        .. versionchanged:: 0.19\n            Deprecated\n\n    Attributes\n    ----------\n    coef_ : array, shape = [1, n_features] if n_classes == 2 else [n_classes,            n_features]\n        Weights assigned to the features.\n\n    intercept_ : array, shape = [1] if n_classes == 2 else [n_classes]\n        Constants in decision function.\n\n    n_iter_ : int\n        The actual number of iterations to reach the stopping criterion.\n        For multiclass fits, it is the maximum over every binary fit.\n\n    Examples\n    --------\n    >>> from sklearn.linear_model import PassiveAggressiveClassifier\n    >>> from sklearn.datasets import make_classification\n    >>>\n    >>> X, y = make_classification(n_features=4, random_state=0)\n    >>> clf = PassiveAggressiveClassifier(max_iter=1000, random_state=0)\n    >>> clf.fit(X, y)\n    PassiveAggressiveClassifier(C=1.0, average=False, class_weight=None,\n                  early_stopping=False, fit_intercept=True, loss='hinge',\n                  max_iter=1000, n_iter=None, n_iter_no_change=5, n_jobs=None,\n                  random_state=0, shuffle=True, tol=None,\n                  validation_fraction=0.1, verbose=0, warm_start=False)\n    >>> print(clf.coef_)\n    [[0.29509834 0.33711843 0.56127352 0.60105546]]\n    >>> print(clf.intercept_)\n    [2.54153383]\n    >>> print(clf.predict([[0, 0, 0, 0]]))\n    [1]\n\n    See also\n    --------\n\n    SGDClassifier\n    Perceptron\n\n    References\n    ----------\n    Online Passive-Aggressive Algorithms\n    <http://jmlr.csail.mit.edu/papers/volume7/crammer06a/crammer06a.pdf>\n    K. Crammer, O. Dekel, J. Keshat, S. Shalev-Shwartz, Y. Singer - JMLR (2006)\n\n    "
        },
        {
            "classifier": "sklearn.linear_model.Perceptron",
            "name": "Perceptron",
            "default_values": [
                {
                    "key": "alpha",
                    "value": 0.0001,
                    "type_": "float"
                },
                {
                    "key": "early_stopping",
                    "value": false,
                    "type_": "bool"
                },
                {
                    "key": "eta0",
                    "value": 1.0,
                    "type_": "float"
                },
                {
                    "key": "fit_intercept",
                    "value": true,
                    "type_": "bool"
                },
                {
                    "key": "n_iter_no_change",
                    "value": 5,
                    "type_": "int"
                },
                {
                    "key": "random_state",
                    "value": 0,
                    "type_": "int"
                },
                {
                    "key": "shuffle",
                    "value": true,
                    "type_": "bool"
                },
                {
                    "key": "validation_fraction",
                    "value": 0.1,
                    "type_": "float"
                },
                {
                    "key": "verbose",
                    "value": 0,
                    "type_": "int"
                },
                {
                    "key": "warm_start",
                    "value": false,
                    "type_": "bool"
                }
            ],
            "doc_string": "Perceptron\n\n    Read more in the :ref:`User Guide <perceptron>`.\n\n    Parameters\n    ----------\n\n    penalty : None, 'l2' or 'l1' or 'elasticnet'\n        The penalty (aka regularization term) to be used. Defaults to None.\n\n    alpha : float\n        Constant that multiplies the regularization term if regularization is\n        used. Defaults to 0.0001\n\n    fit_intercept : bool\n        Whether the intercept should be estimated or not. If False, the\n        data is assumed to be already centered. Defaults to True.\n\n    max_iter : int, optional\n        The maximum number of passes over the training data (aka epochs).\n        It only impacts the behavior in the ``fit`` method, and not the\n        `partial_fit`.\n        Defaults to 5. Defaults to 1000 from 0.21, or if tol is not None.\n\n        .. versionadded:: 0.19\n\n    tol : float or None, optional\n        The stopping criterion. If it is not None, the iterations will stop\n        when (loss > previous_loss - tol). Defaults to None.\n        Defaults to 1e-3 from 0.21.\n\n        .. versionadded:: 0.19\n\n    shuffle : bool, optional, default True\n        Whether or not the training data should be shuffled after each epoch.\n\n    verbose : integer, optional\n        The verbosity level\n\n    eta0 : double\n        Constant by which the updates are multiplied. Defaults to 1.\n\n    n_jobs : int or None, optional (default=None)\n        The number of CPUs to use to do the OVA (One Versus All, for\n        multi-class problems) computation.\n        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n        ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n        for more details.\n\n    random_state : int, RandomState instance or None, optional, default None\n        The seed of the pseudo random number generator to use when shuffling\n        the data.  If int, random_state is the seed used by the random number\n        generator; If RandomState instance, random_state is the random number\n        generator; If None, the random number generator is the RandomState\n        instance used by `np.random`.\n\n    early_stopping : bool, default=False\n        Whether to use early stopping to terminate training when validation.\n        score is not improving. If set to True, it will automatically set aside\n        a fraction of training data as validation and terminate training when\n        validation score is not improving by at least tol for\n        n_iter_no_change consecutive epochs.\n\n        .. versionadded:: 0.20\n\n    validation_fraction : float, default=0.1\n        The proportion of training data to set aside as validation set for\n        early stopping. Must be between 0 and 1.\n        Only used if early_stopping is True.\n\n        .. versionadded:: 0.20\n\n    n_iter_no_change : int, default=5\n        Number of iterations with no improvement to wait before early stopping.\n\n        .. versionadded:: 0.20\n\n    class_weight : dict, {class_label: weight} or \"balanced\" or None, optional\n        Preset for the class_weight fit parameter.\n\n        Weights associated with classes. If not given, all classes\n        are supposed to have weight one.\n\n        The \"balanced\" mode uses the values of y to automatically adjust\n        weights inversely proportional to class frequencies in the input data\n        as ``n_samples / (n_classes * np.bincount(y))``\n\n    warm_start : bool, optional\n        When set to True, reuse the solution of the previous call to fit as\n        initialization, otherwise, just erase the previous solution. See\n        :term:`the Glossary <warm_start>`.\n\n    n_iter : int, optional\n        The number of passes over the training data (aka epochs).\n        Defaults to None. Deprecated, will be removed in 0.21.\n\n        .. versionchanged:: 0.19\n            Deprecated\n\n    Attributes\n    ----------\n    coef_ : array, shape = [1, n_features] if n_classes == 2 else [n_classes,            n_features]\n        Weights assigned to the features.\n\n    intercept_ : array, shape = [1] if n_classes == 2 else [n_classes]\n        Constants in decision function.\n\n    n_iter_ : int\n        The actual number of iterations to reach the stopping criterion.\n        For multiclass fits, it is the maximum over every binary fit.\n\n    Notes\n    -----\n\n    ``Perceptron`` is a classification algorithm which shares the same\n    underlying implementation with ``SGDClassifier``. In fact,\n    ``Perceptron()`` is equivalent to `SGDClassifier(loss=\"perceptron\",\n    eta0=1, learning_rate=\"constant\", penalty=None)`.\n\n    Examples\n    --------\n    >>> from sklearn.datasets import load_digits\n    >>> from sklearn.linear_model import Perceptron\n    >>> X, y = load_digits(return_X_y=True)\n    >>> clf = Perceptron(tol=1e-3, random_state=0)\n    >>> clf.fit(X, y)\n    Perceptron(alpha=0.0001, class_weight=None, early_stopping=False, eta0=1.0,\n          fit_intercept=True, max_iter=None, n_iter=None, n_iter_no_change=5,\n          n_jobs=None, penalty=None, random_state=0, shuffle=True, tol=0.001,\n          validation_fraction=0.1, verbose=0, warm_start=False)\n    >>> clf.score(X, y) # doctest: +ELLIPSIS\n    0.946...\n\n    See also\n    --------\n\n    SGDClassifier\n\n    References\n    ----------\n\n    https://en.wikipedia.org/wiki/Perceptron and references therein.\n    "
        },
        {
            "classifier": "sklearn.linear_model.RidgeClassifier",
            "name": "Ridge Classifier",
            "default_values": [
                {
                    "key": "alpha",
                    "value": 1.0,
                    "type_": "float"
                },
                {
                    "key": "copy_X",
                    "value": true,
                    "type_": "bool"
                },
                {
                    "key": "fit_intercept",
                    "value": true,
                    "type_": "bool"
                },
                {
                    "key": "normalize",
                    "value": false,
                    "type_": "bool"
                },
                {
                    "key": "solver",
                    "value": "auto",
                    "type_": "str"
                },
                {
                    "key": "tol",
                    "value": 0.001,
                    "type_": "float"
                }
            ],
            "doc_string": "Classifier using Ridge regression.\n\n    Read more in the :ref:`User Guide <ridge_regression>`.\n\n    Parameters\n    ----------\n    alpha : float\n        Regularization strength; must be a positive float. Regularization\n        improves the conditioning of the problem and reduces the variance of\n        the estimates. Larger values specify stronger regularization.\n        Alpha corresponds to ``C^-1`` in other linear models such as\n        LogisticRegression or LinearSVC.\n\n    fit_intercept : boolean\n        Whether to calculate the intercept for this model. If set to false, no\n        intercept will be used in calculations (e.g. data is expected to be\n        already centered).\n\n    normalize : boolean, optional, default False\n        This parameter is ignored when ``fit_intercept`` is set to False.\n        If True, the regressors X will be normalized before regression by\n        subtracting the mean and dividing by the l2-norm.\n        If you wish to standardize, please use\n        :class:`sklearn.preprocessing.StandardScaler` before calling ``fit``\n        on an estimator with ``normalize=False``.\n\n    copy_X : boolean, optional, default True\n        If True, X will be copied; else, it may be overwritten.\n\n    max_iter : int, optional\n        Maximum number of iterations for conjugate gradient solver.\n        The default value is determined by scipy.sparse.linalg.\n\n    tol : float\n        Precision of the solution.\n\n    class_weight : dict or 'balanced', optional\n        Weights associated with classes in the form ``{class_label: weight}``.\n        If not given, all classes are supposed to have weight one.\n\n        The \"balanced\" mode uses the values of y to automatically adjust\n        weights inversely proportional to class frequencies in the input data\n        as ``n_samples / (n_classes * np.bincount(y))``\n\n    solver : {'auto', 'svd', 'cholesky', 'lsqr', 'sparse_cg', 'sag', 'saga'}\n        Solver to use in the computational routines:\n\n        - 'auto' chooses the solver automatically based on the type of data.\n\n        - 'svd' uses a Singular Value Decomposition of X to compute the Ridge\n          coefficients. More stable for singular matrices than\n          'cholesky'.\n\n        - 'cholesky' uses the standard scipy.linalg.solve function to\n          obtain a closed-form solution.\n\n        - 'sparse_cg' uses the conjugate gradient solver as found in\n          scipy.sparse.linalg.cg. As an iterative algorithm, this solver is\n          more appropriate than 'cholesky' for large-scale data\n          (possibility to set `tol` and `max_iter`).\n\n        - 'lsqr' uses the dedicated regularized least-squares routine\n          scipy.sparse.linalg.lsqr. It is the fastest and uses an iterative\n          procedure.\n\n        - 'sag' uses a Stochastic Average Gradient descent, and 'saga' uses\n          its unbiased and more flexible version named SAGA. Both methods\n          use an iterative procedure, and are often faster than other solvers\n          when both n_samples and n_features are large. Note that 'sag' and\n          'saga' fast convergence is only guaranteed on features with\n          approximately the same scale. You can preprocess the data with a\n          scaler from sklearn.preprocessing.\n\n          .. versionadded:: 0.17\n             Stochastic Average Gradient descent solver.\n          .. versionadded:: 0.19\n           SAGA solver.\n\n    random_state : int, RandomState instance or None, optional, default None\n        The seed of the pseudo random number generator to use when shuffling\n        the data.  If int, random_state is the seed used by the random number\n        generator; If RandomState instance, random_state is the random number\n        generator; If None, the random number generator is the RandomState\n        instance used by `np.random`. Used when ``solver`` == 'sag'.\n\n    Attributes\n    ----------\n    coef_ : array, shape (n_features,) or (n_classes, n_features)\n        Weight vector(s).\n\n    intercept_ : float | array, shape = (n_targets,)\n        Independent term in decision function. Set to 0.0 if\n        ``fit_intercept = False``.\n\n    n_iter_ : array or None, shape (n_targets,)\n        Actual number of iterations for each target. Available only for\n        sag and lsqr solvers. Other solvers will return None.\n\n    Examples\n    --------\n    >>> from sklearn.datasets import load_breast_cancer\n    >>> from sklearn.linear_model import RidgeClassifier\n    >>> X, y = load_breast_cancer(return_X_y=True)\n    >>> clf = RidgeClassifier().fit(X, y)\n    >>> clf.score(X, y) # doctest: +ELLIPSIS\n    0.9595...\n\n    See also\n    --------\n    Ridge : Ridge regression\n    RidgeClassifierCV :  Ridge classifier with built-in cross validation\n\n    Notes\n    -----\n    For multi-class classification, n_class classifiers are trained in\n    a one-versus-all approach. Concretely, this is implemented by taking\n    advantage of the multi-variate response support in Ridge.\n    "
        },
        {
            "classifier": "sklearn.linear_model.RidgeClassifierCV",
            "name": "Ridge Classifier C V",
            "default_values": [
                {
                    "key": "alphas",
                    "value": [
                        0.1,
                        1.0,
                        10.0
                    ],
                    "type_": "list"
                },
                {
                    "key": "fit_intercept",
                    "value": true,
                    "type_": "bool"
                },
                {
                    "key": "normalize",
                    "value": false,
                    "type_": "bool"
                },
                {
                    "key": "store_cv_values",
                    "value": false,
                    "type_": "bool"
                }
            ],
            "doc_string": "Ridge classifier with built-in cross-validation.\n\n    By default, it performs Generalized Cross-Validation, which is a form of\n    efficient Leave-One-Out cross-validation. Currently, only the n_features >\n    n_samples case is handled efficiently.\n\n    Read more in the :ref:`User Guide <ridge_regression>`.\n\n    Parameters\n    ----------\n    alphas : numpy array of shape [n_alphas]\n        Array of alpha values to try.\n        Regularization strength; must be a positive float. Regularization\n        improves the conditioning of the problem and reduces the variance of\n        the estimates. Larger values specify stronger regularization.\n        Alpha corresponds to ``C^-1`` in other linear models such as\n        LogisticRegression or LinearSVC.\n\n    fit_intercept : boolean\n        Whether to calculate the intercept for this model. If set\n        to false, no intercept will be used in calculations\n        (e.g. data is expected to be already centered).\n\n    normalize : boolean, optional, default False\n        This parameter is ignored when ``fit_intercept`` is set to False.\n        If True, the regressors X will be normalized before regression by\n        subtracting the mean and dividing by the l2-norm.\n        If you wish to standardize, please use\n        :class:`sklearn.preprocessing.StandardScaler` before calling ``fit``\n        on an estimator with ``normalize=False``.\n\n    scoring : string, callable or None, optional, default: None\n        A string (see model evaluation documentation) or\n        a scorer callable object / function with signature\n        ``scorer(estimator, X, y)``.\n\n    cv : int, cross-validation generator or an iterable, optional\n        Determines the cross-validation splitting strategy.\n        Possible inputs for cv are:\n\n        - None, to use the efficient Leave-One-Out cross-validation\n        - integer, to specify the number of folds.\n        - An object to be used as a cross-validation generator.\n        - An iterable yielding train/test splits.\n\n        Refer :ref:`User Guide <cross_validation>` for the various\n        cross-validation strategies that can be used here.\n\n    class_weight : dict or 'balanced', optional\n        Weights associated with classes in the form ``{class_label: weight}``.\n        If not given, all classes are supposed to have weight one.\n\n        The \"balanced\" mode uses the values of y to automatically adjust\n        weights inversely proportional to class frequencies in the input data\n        as ``n_samples / (n_classes * np.bincount(y))``\n\n    store_cv_values : boolean, default=False\n        Flag indicating if the cross-validation values corresponding to\n        each alpha should be stored in the ``cv_values_`` attribute (see\n        below). This flag is only compatible with ``cv=None`` (i.e. using\n        Generalized Cross-Validation).\n\n    Attributes\n    ----------\n    cv_values_ : array, shape = [n_samples, n_targets, n_alphas], optional\n        Cross-validation values for each alpha (if ``store_cv_values=True`` and\n        ``cv=None``). After ``fit()`` has been called, this attribute will\n        contain the mean squared errors (by default) or the values of the\n        ``{loss,score}_func`` function (if provided in the constructor).\n\n    coef_ : array, shape = [n_features] or [n_targets, n_features]\n        Weight vector(s).\n\n    intercept_ : float | array, shape = (n_targets,)\n        Independent term in decision function. Set to 0.0 if\n        ``fit_intercept = False``.\n\n    alpha_ : float\n        Estimated regularization parameter\n\n    Examples\n    --------\n    >>> from sklearn.datasets import load_breast_cancer\n    >>> from sklearn.linear_model import RidgeClassifierCV\n    >>> X, y = load_breast_cancer(return_X_y=True)\n    >>> clf = RidgeClassifierCV(alphas=[1e-3, 1e-2, 1e-1, 1]).fit(X, y)\n    >>> clf.score(X, y) # doctest: +ELLIPSIS\n    0.9630...\n\n    See also\n    --------\n    Ridge : Ridge regression\n    RidgeClassifier : Ridge classifier\n    RidgeCV : Ridge regression with built-in cross validation\n\n    Notes\n    -----\n    For multi-class classification, n_class classifiers are trained in\n    a one-versus-all approach. Concretely, this is implemented by taking\n    advantage of the multi-variate response support in Ridge.\n    "
        },
        {
            "classifier": "sklearn.linear_model.SGDClassifier",
            "name": "S G D Classifier",
            "default_values": [
                {
                    "key": "alpha",
                    "value": 0.0001,
                    "type_": "float"
                },
                {
                    "key": "average",
                    "value": false,
                    "type_": "bool"
                },
                {
                    "key": "early_stopping",
                    "value": false,
                    "type_": "bool"
                },
                {
                    "key": "epsilon",
                    "value": 0.1,
                    "type_": "float"
                },
                {
                    "key": "eta0",
                    "value": 0.0,
                    "type_": "float"
                },
                {
                    "key": "fit_intercept",
                    "value": true,
                    "type_": "bool"
                },
                {
                    "key": "l1_ratio",
                    "value": 0.15,
                    "type_": "float"
                },
                {
                    "key": "learning_rate",
                    "value": "optimal",
                    "type_": "str"
                },
                {
                    "key": "loss",
                    "value": "hinge",
                    "type_": "str"
                },
                {
                    "key": "n_iter_no_change",
                    "value": 5,
                    "type_": "int"
                },
                {
                    "key": "penalty",
                    "value": "l2",
                    "type_": "str"
                },
                {
                    "key": "power_t",
                    "value": 0.5,
                    "type_": "float"
                },
                {
                    "key": "shuffle",
                    "value": true,
                    "type_": "bool"
                },
                {
                    "key": "validation_fraction",
                    "value": 0.1,
                    "type_": "float"
                },
                {
                    "key": "verbose",
                    "value": 0,
                    "type_": "int"
                },
                {
                    "key": "warm_start",
                    "value": false,
                    "type_": "bool"
                }
            ],
            "doc_string": "Linear classifiers (SVM, logistic regression, a.o.) with SGD training.\n\n    This estimator implements regularized linear models with stochastic\n    gradient descent (SGD) learning: the gradient of the loss is estimated\n    each sample at a time and the model is updated along the way with a\n    decreasing strength schedule (aka learning rate). SGD allows minibatch\n    (online/out-of-core) learning, see the partial_fit method.\n    For best results using the default learning rate schedule, the data should\n    have zero mean and unit variance.\n\n    This implementation works with data represented as dense or sparse arrays\n    of floating point values for the features. The model it fits can be\n    controlled with the loss parameter; by default, it fits a linear support\n    vector machine (SVM).\n\n    The regularizer is a penalty added to the loss function that shrinks model\n    parameters towards the zero vector using either the squared euclidean norm\n    L2 or the absolute norm L1 or a combination of both (Elastic Net). If the\n    parameter update crosses the 0.0 value because of the regularizer, the\n    update is truncated to 0.0 to allow for learning sparse models and achieve\n    online feature selection.\n\n    Read more in the :ref:`User Guide <sgd>`.\n\n    Parameters\n    ----------\n    loss : str, default: 'hinge'\n        The loss function to be used. Defaults to 'hinge', which gives a\n        linear SVM.\n\n        The possible options are 'hinge', 'log', 'modified_huber',\n        'squared_hinge', 'perceptron', or a regression loss: 'squared_loss',\n        'huber', 'epsilon_insensitive', or 'squared_epsilon_insensitive'.\n\n        The 'log' loss gives logistic regression, a probabilistic classifier.\n        'modified_huber' is another smooth loss that brings tolerance to\n        outliers as well as probability estimates.\n        'squared_hinge' is like hinge but is quadratically penalized.\n        'perceptron' is the linear loss used by the perceptron algorithm.\n        The other losses are designed for regression but can be useful in\n        classification as well; see SGDRegressor for a description.\n\n    penalty : str, 'none', 'l2', 'l1', or 'elasticnet'\n        The penalty (aka regularization term) to be used. Defaults to 'l2'\n        which is the standard regularizer for linear SVM models. 'l1' and\n        'elasticnet' might bring sparsity to the model (feature selection)\n        not achievable with 'l2'.\n\n    alpha : float\n        Constant that multiplies the regularization term. Defaults to 0.0001\n        Also used to compute learning_rate when set to 'optimal'.\n\n    l1_ratio : float\n        The Elastic Net mixing parameter, with 0 <= l1_ratio <= 1.\n        l1_ratio=0 corresponds to L2 penalty, l1_ratio=1 to L1.\n        Defaults to 0.15.\n\n    fit_intercept : bool\n        Whether the intercept should be estimated or not. If False, the\n        data is assumed to be already centered. Defaults to True.\n\n    max_iter : int, optional\n        The maximum number of passes over the training data (aka epochs).\n        It only impacts the behavior in the ``fit`` method, and not the\n        `partial_fit`.\n        Defaults to 5. Defaults to 1000 from 0.21, or if tol is not None.\n\n        .. versionadded:: 0.19\n\n    tol : float or None, optional\n        The stopping criterion. If it is not None, the iterations will stop\n        when (loss > previous_loss - tol). Defaults to None.\n        Defaults to 1e-3 from 0.21.\n\n        .. versionadded:: 0.19\n\n    shuffle : bool, optional\n        Whether or not the training data should be shuffled after each epoch.\n        Defaults to True.\n\n    verbose : integer, optional\n        The verbosity level\n\n    epsilon : float\n        Epsilon in the epsilon-insensitive loss functions; only if `loss` is\n        'huber', 'epsilon_insensitive', or 'squared_epsilon_insensitive'.\n        For 'huber', determines the threshold at which it becomes less\n        important to get the prediction exactly right.\n        For epsilon-insensitive, any differences between the current prediction\n        and the correct label are ignored if they are less than this threshold.\n\n    n_jobs : int or None, optional (default=None)\n        The number of CPUs to use to do the OVA (One Versus All, for\n        multi-class problems) computation.\n        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n        ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n        for more details.\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        The seed of the pseudo random number generator to use when shuffling\n        the data.  If int, random_state is the seed used by the random number\n        generator; If RandomState instance, random_state is the random number\n        generator; If None, the random number generator is the RandomState\n        instance used by `np.random`.\n\n    learning_rate : string, optional\n        The learning rate schedule:\n\n        'constant':\n            eta = eta0\n        'optimal': [default]\n            eta = 1.0 / (alpha * (t + t0))\n            where t0 is chosen by a heuristic proposed by Leon Bottou.\n        'invscaling':\n            eta = eta0 / pow(t, power_t)\n        'adaptive':\n            eta = eta0, as long as the training keeps decreasing.\n            Each time n_iter_no_change consecutive epochs fail to decrease the\n            training loss by tol or fail to increase validation score by tol if\n            early_stopping is True, the current learning rate is divided by 5.\n\n    eta0 : double\n        The initial learning rate for the 'constant', 'invscaling' or\n        'adaptive' schedules. The default value is 0.0 as eta0 is not used by\n        the default schedule 'optimal'.\n\n    power_t : double\n        The exponent for inverse scaling learning rate [default 0.5].\n\n    early_stopping : bool, default=False\n        Whether to use early stopping to terminate training when validation\n        score is not improving. If set to True, it will automatically set aside\n        a fraction of training data as validation and terminate training when\n        validation score is not improving by at least tol for\n        n_iter_no_change consecutive epochs.\n\n        .. versionadded:: 0.20\n\n    validation_fraction : float, default=0.1\n        The proportion of training data to set aside as validation set for\n        early stopping. Must be between 0 and 1.\n        Only used if early_stopping is True.\n\n        .. versionadded:: 0.20\n\n    n_iter_no_change : int, default=5\n        Number of iterations with no improvement to wait before early stopping.\n\n        .. versionadded:: 0.20\n\n    class_weight : dict, {class_label: weight} or \"balanced\" or None, optional\n        Preset for the class_weight fit parameter.\n\n        Weights associated with classes. If not given, all classes\n        are supposed to have weight one.\n\n        The \"balanced\" mode uses the values of y to automatically adjust\n        weights inversely proportional to class frequencies in the input data\n        as ``n_samples / (n_classes * np.bincount(y))``\n\n    warm_start : bool, optional\n        When set to True, reuse the solution of the previous call to fit as\n        initialization, otherwise, just erase the previous solution.\n        See :term:`the Glossary <warm_start>`.\n\n        Repeatedly calling fit or partial_fit when warm_start is True can\n        result in a different solution than when calling fit a single time\n        because of the way the data is shuffled.\n        If a dynamic learning rate is used, the learning rate is adapted\n        depending on the number of samples already seen. Calling ``fit`` resets\n        this counter, while ``partial_fit`` will result in increasing the\n        existing counter.\n\n    average : bool or int, optional\n        When set to True, computes the averaged SGD weights and stores the\n        result in the ``coef_`` attribute. If set to an int greater than 1,\n        averaging will begin once the total number of samples seen reaches\n        average. So ``average=10`` will begin averaging after seeing 10\n        samples.\n\n    n_iter : int, optional\n        The number of passes over the training data (aka epochs).\n        Defaults to None. Deprecated, will be removed in 0.21.\n\n        .. versionchanged:: 0.19\n            Deprecated\n\n    Attributes\n    ----------\n    coef_ : array, shape (1, n_features) if n_classes == 2 else (n_classes,            n_features)\n        Weights assigned to the features.\n\n    intercept_ : array, shape (1,) if n_classes == 2 else (n_classes,)\n        Constants in decision function.\n\n    n_iter_ : int\n        The actual number of iterations to reach the stopping criterion.\n        For multiclass fits, it is the maximum over every binary fit.\n\n    loss_function_ : concrete ``LossFunction``\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn import linear_model\n    >>> X = np.array([[-1, -1], [-2, -1], [1, 1], [2, 1]])\n    >>> Y = np.array([1, 1, 2, 2])\n    >>> clf = linear_model.SGDClassifier(max_iter=1000)\n    >>> clf.fit(X, Y)\n    ... #doctest: +NORMALIZE_WHITESPACE\n    SGDClassifier(alpha=0.0001, average=False, class_weight=None,\n           early_stopping=False, epsilon=0.1, eta0=0.0, fit_intercept=True,\n           l1_ratio=0.15, learning_rate='optimal', loss='hinge', max_iter=1000,\n           n_iter=None, n_iter_no_change=5, n_jobs=None, penalty='l2',\n           power_t=0.5, random_state=None, shuffle=True, tol=None,\n           validation_fraction=0.1, verbose=0, warm_start=False)\n\n    >>> print(clf.predict([[-0.8, -1]]))\n    [1]\n\n    See also\n    --------\n    sklearn.svm.LinearSVC, LogisticRegression, Perceptron\n\n    "
        },
        {
            "classifier": "sklearn.naive_bayes.BernoulliNB",
            "name": "Bernoulli N B",
            "default_values": [
                {
                    "key": "alpha",
                    "value": 1.0,
                    "type_": "float"
                },
                {
                    "key": "binarize",
                    "value": 0.0,
                    "type_": "float"
                },
                {
                    "key": "fit_prior",
                    "value": true,
                    "type_": "bool"
                }
            ],
            "doc_string": "Naive Bayes classifier for multivariate Bernoulli models.\n\n    Like MultinomialNB, this classifier is suitable for discrete data. The\n    difference is that while MultinomialNB works with occurrence counts,\n    BernoulliNB is designed for binary/boolean features.\n\n    Read more in the :ref:`User Guide <bernoulli_naive_bayes>`.\n\n    Parameters\n    ----------\n    alpha : float, optional (default=1.0)\n        Additive (Laplace/Lidstone) smoothing parameter\n        (0 for no smoothing).\n\n    binarize : float or None, optional (default=0.0)\n        Threshold for binarizing (mapping to booleans) of sample features.\n        If None, input is presumed to already consist of binary vectors.\n\n    fit_prior : boolean, optional (default=True)\n        Whether to learn class prior probabilities or not.\n        If false, a uniform prior will be used.\n\n    class_prior : array-like, size=[n_classes,], optional (default=None)\n        Prior probabilities of the classes. If specified the priors are not\n        adjusted according to the data.\n\n    Attributes\n    ----------\n    class_log_prior_ : array, shape = [n_classes]\n        Log probability of each class (smoothed).\n\n    feature_log_prob_ : array, shape = [n_classes, n_features]\n        Empirical log probability of features given a class, P(x_i|y).\n\n    class_count_ : array, shape = [n_classes]\n        Number of samples encountered for each class during fitting. This\n        value is weighted by the sample weight when provided.\n\n    feature_count_ : array, shape = [n_classes, n_features]\n        Number of samples encountered for each (class, feature)\n        during fitting. This value is weighted by the sample weight when\n        provided.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> X = np.random.randint(2, size=(6, 100))\n    >>> Y = np.array([1, 2, 3, 4, 4, 5])\n    >>> from sklearn.naive_bayes import BernoulliNB\n    >>> clf = BernoulliNB()\n    >>> clf.fit(X, Y)\n    BernoulliNB(alpha=1.0, binarize=0.0, class_prior=None, fit_prior=True)\n    >>> print(clf.predict(X[2:3]))\n    [3]\n\n    References\n    ----------\n\n    C.D. Manning, P. Raghavan and H. Schuetze (2008). Introduction to\n    Information Retrieval. Cambridge University Press, pp. 234-265.\n    http://nlp.stanford.edu/IR-book/html/htmledition/the-bernoulli-model-1.html\n\n    A. McCallum and K. Nigam (1998). A comparison of event models for naive\n    Bayes text classification. Proc. AAAI/ICML-98 Workshop on Learning for\n    Text Categorization, pp. 41-48.\n\n    V. Metsis, I. Androutsopoulos and G. Paliouras (2006). Spam filtering with\n    naive Bayes -- Which naive Bayes? 3rd Conf. on Email and Anti-Spam (CEAS).\n    "
        },
        {
            "classifier": "sklearn.naive_bayes.ComplementNB",
            "name": "Complement N B",
            "default_values": [
                {
                    "key": "alpha",
                    "value": 1.0,
                    "type_": "float"
                },
                {
                    "key": "fit_prior",
                    "value": true,
                    "type_": "bool"
                },
                {
                    "key": "norm",
                    "value": false,
                    "type_": "bool"
                }
            ],
            "doc_string": "The Complement Naive Bayes classifier described in Rennie et al. (2003).\n\n    The Complement Naive Bayes classifier was designed to correct the \"severe\n    assumptions\" made by the standard Multinomial Naive Bayes classifier. It is\n    particularly suited for imbalanced data sets.\n\n    Read more in the :ref:`User Guide <complement_naive_bayes>`.\n\n    Parameters\n    ----------\n    alpha : float, optional (default=1.0)\n        Additive (Laplace/Lidstone) smoothing parameter (0 for no smoothing).\n\n    fit_prior : boolean, optional (default=True)\n        Only used in edge case with a single class in the training set.\n\n    class_prior : array-like, size (n_classes,), optional (default=None)\n        Prior probabilities of the classes. Not used.\n\n    norm : boolean, optional (default=False)\n        Whether or not a second normalization of the weights is performed. The\n        default behavior mirrors the implementations found in Mahout and Weka,\n        which do not follow the full algorithm described in Table 9 of the\n        paper.\n\n    Attributes\n    ----------\n    class_log_prior_ : array, shape (n_classes, )\n        Smoothed empirical log probability for each class. Only used in edge\n        case with a single class in the training set.\n\n    feature_log_prob_ : array, shape (n_classes, n_features)\n        Empirical weights for class complements.\n\n    class_count_ : array, shape (n_classes,)\n        Number of samples encountered for each class during fitting. This\n        value is weighted by the sample weight when provided.\n\n    feature_count_ : array, shape (n_classes, n_features)\n        Number of samples encountered for each (class, feature) during fitting.\n        This value is weighted by the sample weight when provided.\n\n    feature_all_ : array, shape (n_features,)\n        Number of samples encountered for each feature during fitting. This\n        value is weighted by the sample weight when provided.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> X = np.random.randint(5, size=(6, 100))\n    >>> y = np.array([1, 2, 3, 4, 5, 6])\n    >>> from sklearn.naive_bayes import ComplementNB\n    >>> clf = ComplementNB()\n    >>> clf.fit(X, y)\n    ComplementNB(alpha=1.0, class_prior=None, fit_prior=True, norm=False)\n    >>> print(clf.predict(X[2:3]))\n    [3]\n\n    References\n    ----------\n    Rennie, J. D., Shih, L., Teevan, J., & Karger, D. R. (2003).\n    Tackling the poor assumptions of naive bayes text classifiers. In ICML\n    (Vol. 3, pp. 616-623).\n    http://people.csail.mit.edu/jrennie/papers/icml03-nb.pdf\n    "
        },
        {
            "classifier": "sklearn.naive_bayes.GaussianNB",
            "name": "Gaussian N B",
            "default_values": [
                {
                    "key": "var_smoothing",
                    "value": 1e-09,
                    "type_": "float"
                }
            ],
            "doc_string": "\n    Gaussian Naive Bayes (GaussianNB)\n\n    Can perform online updates to model parameters via `partial_fit` method.\n    For details on algorithm used to update feature means and variance online,\n    see Stanford CS tech report STAN-CS-79-773 by Chan, Golub, and LeVeque:\n\n        http://i.stanford.edu/pub/cstr/reports/cs/tr/79/773/CS-TR-79-773.pdf\n\n    Read more in the :ref:`User Guide <gaussian_naive_bayes>`.\n\n    Parameters\n    ----------\n    priors : array-like, shape (n_classes,)\n        Prior probabilities of the classes. If specified the priors are not\n        adjusted according to the data.\n\n    var_smoothing : float, optional (default=1e-9)\n        Portion of the largest variance of all features that is added to\n        variances for calculation stability.\n\n    Attributes\n    ----------\n    class_prior_ : array, shape (n_classes,)\n        probability of each class.\n\n    class_count_ : array, shape (n_classes,)\n        number of training samples observed in each class.\n\n    theta_ : array, shape (n_classes, n_features)\n        mean of each feature per class\n\n    sigma_ : array, shape (n_classes, n_features)\n        variance of each feature per class\n\n    epsilon_ : float\n        absolute additive value to variances\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> X = np.array([[-1, -1], [-2, -1], [-3, -2], [1, 1], [2, 1], [3, 2]])\n    >>> Y = np.array([1, 1, 1, 2, 2, 2])\n    >>> from sklearn.naive_bayes import GaussianNB\n    >>> clf = GaussianNB()\n    >>> clf.fit(X, Y)\n    GaussianNB(priors=None, var_smoothing=1e-09)\n    >>> print(clf.predict([[-0.8, -1]]))\n    [1]\n    >>> clf_pf = GaussianNB()\n    >>> clf_pf.partial_fit(X, Y, np.unique(Y))\n    GaussianNB(priors=None, var_smoothing=1e-09)\n    >>> print(clf_pf.predict([[-0.8, -1]]))\n    [1]\n    "
        },
        {
            "classifier": "sklearn.naive_bayes.MultinomialNB",
            "name": "Multinomial N B",
            "default_values": [
                {
                    "key": "alpha",
                    "value": 1.0,
                    "type_": "float"
                },
                {
                    "key": "fit_prior",
                    "value": true,
                    "type_": "bool"
                }
            ],
            "doc_string": "\n    Naive Bayes classifier for multinomial models\n\n    The multinomial Naive Bayes classifier is suitable for classification with\n    discrete features (e.g., word counts for text classification). The\n    multinomial distribution normally requires integer feature counts. However,\n    in practice, fractional counts such as tf-idf may also work.\n\n    Read more in the :ref:`User Guide <multinomial_naive_bayes>`.\n\n    Parameters\n    ----------\n    alpha : float, optional (default=1.0)\n        Additive (Laplace/Lidstone) smoothing parameter\n        (0 for no smoothing).\n\n    fit_prior : boolean, optional (default=True)\n        Whether to learn class prior probabilities or not.\n        If false, a uniform prior will be used.\n\n    class_prior : array-like, size (n_classes,), optional (default=None)\n        Prior probabilities of the classes. If specified the priors are not\n        adjusted according to the data.\n\n    Attributes\n    ----------\n    class_log_prior_ : array, shape (n_classes, )\n        Smoothed empirical log probability for each class.\n\n    intercept_ : array, shape (n_classes, )\n        Mirrors ``class_log_prior_`` for interpreting MultinomialNB\n        as a linear model.\n\n    feature_log_prob_ : array, shape (n_classes, n_features)\n        Empirical log probability of features\n        given a class, ``P(x_i|y)``.\n\n    coef_ : array, shape (n_classes, n_features)\n        Mirrors ``feature_log_prob_`` for interpreting MultinomialNB\n        as a linear model.\n\n    class_count_ : array, shape (n_classes,)\n        Number of samples encountered for each class during fitting. This\n        value is weighted by the sample weight when provided.\n\n    feature_count_ : array, shape (n_classes, n_features)\n        Number of samples encountered for each (class, feature)\n        during fitting. This value is weighted by the sample weight when\n        provided.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> X = np.random.randint(5, size=(6, 100))\n    >>> y = np.array([1, 2, 3, 4, 5, 6])\n    >>> from sklearn.naive_bayes import MultinomialNB\n    >>> clf = MultinomialNB()\n    >>> clf.fit(X, y)\n    MultinomialNB(alpha=1.0, class_prior=None, fit_prior=True)\n    >>> print(clf.predict(X[2:3]))\n    [3]\n\n    Notes\n    -----\n    For the rationale behind the names `coef_` and `intercept_`, i.e.\n    naive Bayes as a linear classifier, see J. Rennie et al. (2003),\n    Tackling the poor assumptions of naive Bayes text classifiers, ICML.\n\n    References\n    ----------\n    C.D. Manning, P. Raghavan and H. Schuetze (2008). Introduction to\n    Information Retrieval. Cambridge University Press, pp. 234-265.\n    http://nlp.stanford.edu/IR-book/html/htmledition/naive-bayes-text-classification-1.html\n    "
        },
        {
            "classifier": "sklearn.neural_network.MLPClassifier",
            "name": "M L P Classifier",
            "default_values": [
                {
                    "key": "activation",
                    "value": "relu",
                    "type_": "str"
                },
                {
                    "key": "alpha",
                    "value": 0.0001,
                    "type_": "float"
                },
                {
                    "key": "batch_size",
                    "value": "auto",
                    "type_": "str"
                },
                {
                    "key": "beta_1",
                    "value": 0.9,
                    "type_": "float"
                },
                {
                    "key": "beta_2",
                    "value": 0.999,
                    "type_": "float"
                },
                {
                    "key": "early_stopping",
                    "value": false,
                    "type_": "bool"
                },
                {
                    "key": "epsilon",
                    "value": 1e-08,
                    "type_": "float"
                },
                {
                    "key": "hidden_layer_sizes",
                    "value": [
                        100
                    ],
                    "type_": "tuple"
                },
                {
                    "key": "learning_rate",
                    "value": "constant",
                    "type_": "str"
                },
                {
                    "key": "learning_rate_init",
                    "value": 0.001,
                    "type_": "float"
                },
                {
                    "key": "max_iter",
                    "value": 200,
                    "type_": "int"
                },
                {
                    "key": "momentum",
                    "value": 0.9,
                    "type_": "float"
                },
                {
                    "key": "n_iter_no_change",
                    "value": 10,
                    "type_": "int"
                },
                {
                    "key": "nesterovs_momentum",
                    "value": true,
                    "type_": "bool"
                },
                {
                    "key": "power_t",
                    "value": 0.5,
                    "type_": "float"
                },
                {
                    "key": "shuffle",
                    "value": true,
                    "type_": "bool"
                },
                {
                    "key": "solver",
                    "value": "adam",
                    "type_": "str"
                },
                {
                    "key": "tol",
                    "value": 0.0001,
                    "type_": "float"
                },
                {
                    "key": "validation_fraction",
                    "value": 0.1,
                    "type_": "float"
                },
                {
                    "key": "verbose",
                    "value": false,
                    "type_": "bool"
                },
                {
                    "key": "warm_start",
                    "value": false,
                    "type_": "bool"
                }
            ],
            "doc_string": "Multi-layer Perceptron classifier.\n\n    This model optimizes the log-loss function using LBFGS or stochastic\n    gradient descent.\n\n    .. versionadded:: 0.18\n\n    Parameters\n    ----------\n    hidden_layer_sizes : tuple, length = n_layers - 2, default (100,)\n        The ith element represents the number of neurons in the ith\n        hidden layer.\n\n    activation : {'identity', 'logistic', 'tanh', 'relu'}, default 'relu'\n        Activation function for the hidden layer.\n\n        - 'identity', no-op activation, useful to implement linear bottleneck,\n          returns f(x) = x\n\n        - 'logistic', the logistic sigmoid function,\n          returns f(x) = 1 / (1 + exp(-x)).\n\n        - 'tanh', the hyperbolic tan function,\n          returns f(x) = tanh(x).\n\n        - 'relu', the rectified linear unit function,\n          returns f(x) = max(0, x)\n\n    solver : {'lbfgs', 'sgd', 'adam'}, default 'adam'\n        The solver for weight optimization.\n\n        - 'lbfgs' is an optimizer in the family of quasi-Newton methods.\n\n        - 'sgd' refers to stochastic gradient descent.\n\n        - 'adam' refers to a stochastic gradient-based optimizer proposed\n          by Kingma, Diederik, and Jimmy Ba\n\n        Note: The default solver 'adam' works pretty well on relatively\n        large datasets (with thousands of training samples or more) in terms of\n        both training time and validation score.\n        For small datasets, however, 'lbfgs' can converge faster and perform\n        better.\n\n    alpha : float, optional, default 0.0001\n        L2 penalty (regularization term) parameter.\n\n    batch_size : int, optional, default 'auto'\n        Size of minibatches for stochastic optimizers.\n        If the solver is 'lbfgs', the classifier will not use minibatch.\n        When set to \"auto\", `batch_size=min(200, n_samples)`\n\n    learning_rate : {'constant', 'invscaling', 'adaptive'}, default 'constant'\n        Learning rate schedule for weight updates.\n\n        - 'constant' is a constant learning rate given by\n          'learning_rate_init'.\n\n        - 'invscaling' gradually decreases the learning rate ``learning_rate_``\n          at each time step 't' using an inverse scaling exponent of 'power_t'.\n          effective_learning_rate = learning_rate_init / pow(t, power_t)\n\n        - 'adaptive' keeps the learning rate constant to\n          'learning_rate_init' as long as training loss keeps decreasing.\n          Each time two consecutive epochs fail to decrease training loss by at\n          least tol, or fail to increase validation score by at least tol if\n          'early_stopping' is on, the current learning rate is divided by 5.\n\n        Only used when ``solver='sgd'``.\n\n    learning_rate_init : double, optional, default 0.001\n        The initial learning rate used. It controls the step-size\n        in updating the weights. Only used when solver='sgd' or 'adam'.\n\n    power_t : double, optional, default 0.5\n        The exponent for inverse scaling learning rate.\n        It is used in updating effective learning rate when the learning_rate\n        is set to 'invscaling'. Only used when solver='sgd'.\n\n    max_iter : int, optional, default 200\n        Maximum number of iterations. The solver iterates until convergence\n        (determined by 'tol') or this number of iterations. For stochastic\n        solvers ('sgd', 'adam'), note that this determines the number of epochs\n        (how many times each data point will be used), not the number of\n        gradient steps.\n\n    shuffle : bool, optional, default True\n        Whether to shuffle samples in each iteration. Only used when\n        solver='sgd' or 'adam'.\n\n    random_state : int, RandomState instance or None, optional, default None\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    tol : float, optional, default 1e-4\n        Tolerance for the optimization. When the loss or score is not improving\n        by at least ``tol`` for ``n_iter_no_change`` consecutive iterations,\n        unless ``learning_rate`` is set to 'adaptive', convergence is\n        considered to be reached and training stops.\n\n    verbose : bool, optional, default False\n        Whether to print progress messages to stdout.\n\n    warm_start : bool, optional, default False\n        When set to True, reuse the solution of the previous\n        call to fit as initialization, otherwise, just erase the\n        previous solution. See :term:`the Glossary <warm_start>`.\n\n    momentum : float, default 0.9\n        Momentum for gradient descent update. Should be between 0 and 1. Only\n        used when solver='sgd'.\n\n    nesterovs_momentum : boolean, default True\n        Whether to use Nesterov's momentum. Only used when solver='sgd' and\n        momentum > 0.\n\n    early_stopping : bool, default False\n        Whether to use early stopping to terminate training when validation\n        score is not improving. If set to true, it will automatically set\n        aside 10% of training data as validation and terminate training when\n        validation score is not improving by at least tol for\n        ``n_iter_no_change`` consecutive epochs.\n        Only effective when solver='sgd' or 'adam'\n\n    validation_fraction : float, optional, default 0.1\n        The proportion of training data to set aside as validation set for\n        early stopping. Must be between 0 and 1.\n        Only used if early_stopping is True\n\n    beta_1 : float, optional, default 0.9\n        Exponential decay rate for estimates of first moment vector in adam,\n        should be in [0, 1). Only used when solver='adam'\n\n    beta_2 : float, optional, default 0.999\n        Exponential decay rate for estimates of second moment vector in adam,\n        should be in [0, 1). Only used when solver='adam'\n\n    epsilon : float, optional, default 1e-8\n        Value for numerical stability in adam. Only used when solver='adam'\n\n    n_iter_no_change : int, optional, default 10\n        Maximum number of epochs to not meet ``tol`` improvement.\n        Only effective when solver='sgd' or 'adam'\n\n        .. versionadded:: 0.20\n\n    Attributes\n    ----------\n    classes_ : array or list of array of shape (n_classes,)\n        Class labels for each output.\n\n    loss_ : float\n        The current loss computed with the loss function.\n\n    coefs_ : list, length n_layers - 1\n        The ith element in the list represents the weight matrix corresponding\n        to layer i.\n\n    intercepts_ : list, length n_layers - 1\n        The ith element in the list represents the bias vector corresponding to\n        layer i + 1.\n\n    n_iter_ : int,\n        The number of iterations the solver has ran.\n\n    n_layers_ : int\n        Number of layers.\n\n    n_outputs_ : int\n        Number of outputs.\n\n    out_activation_ : string\n        Name of the output activation function.\n\n    Notes\n    -----\n    MLPClassifier trains iteratively since at each time step\n    the partial derivatives of the loss function with respect to the model\n    parameters are computed to update the parameters.\n\n    It can also have a regularization term added to the loss function\n    that shrinks model parameters to prevent overfitting.\n\n    This implementation works with data represented as dense numpy arrays or\n    sparse scipy arrays of floating point values.\n\n    References\n    ----------\n    Hinton, Geoffrey E.\n        \"Connectionist learning procedures.\" Artificial intelligence 40.1\n        (1989): 185-234.\n\n    Glorot, Xavier, and Yoshua Bengio. \"Understanding the difficulty of\n        training deep feedforward neural networks.\" International Conference\n        on Artificial Intelligence and Statistics. 2010.\n\n    He, Kaiming, et al. \"Delving deep into rectifiers: Surpassing human-level\n        performance on imagenet classification.\" arXiv preprint\n        arXiv:1502.01852 (2015).\n\n    Kingma, Diederik, and Jimmy Ba. \"Adam: A method for stochastic\n        optimization.\" arXiv preprint arXiv:1412.6980 (2014).\n    "
        },
        {
            "classifier": "sklearn.svm.LinearSVC",
            "name": "Linear S V C",
            "default_values": [
                {
                    "key": "C",
                    "value": 1.0,
                    "type_": "float"
                },
                {
                    "key": "dual",
                    "value": true,
                    "type_": "bool"
                },
                {
                    "key": "fit_intercept",
                    "value": true,
                    "type_": "bool"
                },
                {
                    "key": "intercept_scaling",
                    "value": 1,
                    "type_": "int"
                },
                {
                    "key": "loss",
                    "value": "squared_hinge",
                    "type_": "str"
                },
                {
                    "key": "max_iter",
                    "value": 1000,
                    "type_": "int"
                },
                {
                    "key": "multi_class",
                    "value": "ovr",
                    "type_": "str"
                },
                {
                    "key": "penalty",
                    "value": "l2",
                    "type_": "str"
                },
                {
                    "key": "tol",
                    "value": 0.0001,
                    "type_": "float"
                },
                {
                    "key": "verbose",
                    "value": 0,
                    "type_": "int"
                }
            ],
            "doc_string": "Linear Support Vector Classification.\n\n    Similar to SVC with parameter kernel='linear', but implemented in terms of\n    liblinear rather than libsvm, so it has more flexibility in the choice of\n    penalties and loss functions and should scale better to large numbers of\n    samples.\n\n    This class supports both dense and sparse input and the multiclass support\n    is handled according to a one-vs-the-rest scheme.\n\n    Read more in the :ref:`User Guide <svm_classification>`.\n\n    Parameters\n    ----------\n    penalty : string, 'l1' or 'l2' (default='l2')\n        Specifies the norm used in the penalization. The 'l2'\n        penalty is the standard used in SVC. The 'l1' leads to ``coef_``\n        vectors that are sparse.\n\n    loss : string, 'hinge' or 'squared_hinge' (default='squared_hinge')\n        Specifies the loss function. 'hinge' is the standard SVM loss\n        (used e.g. by the SVC class) while 'squared_hinge' is the\n        square of the hinge loss.\n\n    dual : bool, (default=True)\n        Select the algorithm to either solve the dual or primal\n        optimization problem. Prefer dual=False when n_samples > n_features.\n\n    tol : float, optional (default=1e-4)\n        Tolerance for stopping criteria.\n\n    C : float, optional (default=1.0)\n        Penalty parameter C of the error term.\n\n    multi_class : string, 'ovr' or 'crammer_singer' (default='ovr')\n        Determines the multi-class strategy if `y` contains more than\n        two classes.\n        ``\"ovr\"`` trains n_classes one-vs-rest classifiers, while\n        ``\"crammer_singer\"`` optimizes a joint objective over all classes.\n        While `crammer_singer` is interesting from a theoretical perspective\n        as it is consistent, it is seldom used in practice as it rarely leads\n        to better accuracy and is more expensive to compute.\n        If ``\"crammer_singer\"`` is chosen, the options loss, penalty and dual\n        will be ignored.\n\n    fit_intercept : boolean, optional (default=True)\n        Whether to calculate the intercept for this model. If set\n        to false, no intercept will be used in calculations\n        (i.e. data is expected to be already centered).\n\n    intercept_scaling : float, optional (default=1)\n        When self.fit_intercept is True, instance vector x becomes\n        ``[x, self.intercept_scaling]``,\n        i.e. a \"synthetic\" feature with constant value equals to\n        intercept_scaling is appended to the instance vector.\n        The intercept becomes intercept_scaling * synthetic feature weight\n        Note! the synthetic feature weight is subject to l1/l2 regularization\n        as all other features.\n        To lessen the effect of regularization on synthetic feature weight\n        (and therefore on the intercept) intercept_scaling has to be increased.\n\n    class_weight : {dict, 'balanced'}, optional\n        Set the parameter C of class i to ``class_weight[i]*C`` for\n        SVC. If not given, all classes are supposed to have\n        weight one.\n        The \"balanced\" mode uses the values of y to automatically adjust\n        weights inversely proportional to class frequencies in the input data\n        as ``n_samples / (n_classes * np.bincount(y))``\n\n    verbose : int, (default=0)\n        Enable verbose output. Note that this setting takes advantage of a\n        per-process runtime setting in liblinear that, if enabled, may not work\n        properly in a multithreaded context.\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        The seed of the pseudo random number generator to use when shuffling\n        the data for the dual coordinate descent (if ``dual=True``). When\n        ``dual=False`` the underlying implementation of :class:`LinearSVC`\n        is not random and ``random_state`` has no effect on the results. If\n        int, random_state is the seed used by the random number generator; If\n        RandomState instance, random_state is the random number generator; If\n        None, the random number generator is the RandomState instance used by\n        `np.random`.\n\n    max_iter : int, (default=1000)\n        The maximum number of iterations to be run.\n\n    Attributes\n    ----------\n    coef_ : array, shape = [n_features] if n_classes == 2 else [n_classes, n_features]\n        Weights assigned to the features (coefficients in the primal\n        problem). This is only available in the case of a linear kernel.\n\n        ``coef_`` is a readonly property derived from ``raw_coef_`` that\n        follows the internal memory layout of liblinear.\n\n    intercept_ : array, shape = [1] if n_classes == 2 else [n_classes]\n        Constants in decision function.\n\n    Examples\n    --------\n    >>> from sklearn.svm import LinearSVC\n    >>> from sklearn.datasets import make_classification\n    >>> X, y = make_classification(n_features=4, random_state=0)\n    >>> clf = LinearSVC(random_state=0, tol=1e-5)\n    >>> clf.fit(X, y)\n    LinearSVC(C=1.0, class_weight=None, dual=True, fit_intercept=True,\n         intercept_scaling=1, loss='squared_hinge', max_iter=1000,\n         multi_class='ovr', penalty='l2', random_state=0, tol=1e-05, verbose=0)\n    >>> print(clf.coef_)\n    [[0.085... 0.394... 0.498... 0.375...]]\n    >>> print(clf.intercept_)\n    [0.284...]\n    >>> print(clf.predict([[0, 0, 0, 0]]))\n    [1]\n\n    Notes\n    -----\n    The underlying C implementation uses a random number generator to\n    select features when fitting the model. It is thus not uncommon\n    to have slightly different results for the same input data. If\n    that happens, try with a smaller ``tol`` parameter.\n\n    The underlying implementation, liblinear, uses a sparse internal\n    representation for the data that will incur a memory copy.\n\n    Predict output may not match that of standalone liblinear in certain\n    cases. See :ref:`differences from liblinear <liblinear_differences>`\n    in the narrative documentation.\n\n    References\n    ----------\n    `LIBLINEAR: A Library for Large Linear Classification\n    <http://www.csie.ntu.edu.tw/~cjlin/liblinear/>`__\n\n    See also\n    --------\n    SVC\n        Implementation of Support Vector Machine classifier using libsvm:\n        the kernel can be non-linear but its SMO algorithm does not\n        scale to large number of samples as LinearSVC does.\n\n        Furthermore SVC multi-class mode is implemented using one\n        vs one scheme while LinearSVC uses one vs the rest. It is\n        possible to implement one vs the rest with SVC by using the\n        :class:`sklearn.multiclass.OneVsRestClassifier` wrapper.\n\n        Finally SVC can fit dense data without memory copy if the input\n        is C-contiguous. Sparse data will still incur memory copy though.\n\n    sklearn.linear_model.SGDClassifier\n        SGDClassifier can optimize the same cost function as LinearSVC\n        by adjusting the penalty and loss parameters. In addition it requires\n        less memory, allows incremental (online) learning, and implements\n        various loss functions and regularization regimes.\n\n    "
        },
        {
            "classifier": "sklearn.svm.NuSVC",
            "name": "Nu S V C",
            "default_values": [
                {
                    "key": "cache_size",
                    "value": 200,
                    "type_": "int"
                },
                {
                    "key": "coef0",
                    "value": 0.0,
                    "type_": "float"
                },
                {
                    "key": "decision_function_shape",
                    "value": "ovr",
                    "type_": "str"
                },
                {
                    "key": "degree",
                    "value": 3,
                    "type_": "int"
                },
                {
                    "key": "gamma",
                    "value": "auto_deprecated",
                    "type_": "str"
                },
                {
                    "key": "kernel",
                    "value": "rbf",
                    "type_": "str"
                },
                {
                    "key": "max_iter",
                    "value": -1,
                    "type_": "int"
                },
                {
                    "key": "nu",
                    "value": 0.5,
                    "type_": "float"
                },
                {
                    "key": "probability",
                    "value": false,
                    "type_": "bool"
                },
                {
                    "key": "shrinking",
                    "value": true,
                    "type_": "bool"
                },
                {
                    "key": "tol",
                    "value": 0.001,
                    "type_": "float"
                },
                {
                    "key": "verbose",
                    "value": false,
                    "type_": "bool"
                }
            ],
            "doc_string": "Nu-Support Vector Classification.\n\n    Similar to SVC but uses a parameter to control the number of support\n    vectors.\n\n    The implementation is based on libsvm.\n\n    Read more in the :ref:`User Guide <svm_classification>`.\n\n    Parameters\n    ----------\n    nu : float, optional (default=0.5)\n        An upper bound on the fraction of training errors and a lower\n        bound of the fraction of support vectors. Should be in the\n        interval (0, 1].\n\n    kernel : string, optional (default='rbf')\n         Specifies the kernel type to be used in the algorithm.\n         It must be one of 'linear', 'poly', 'rbf', 'sigmoid', 'precomputed' or\n         a callable.\n         If none is given, 'rbf' will be used. If a callable is given it is\n         used to precompute the kernel matrix.\n\n    degree : int, optional (default=3)\n        Degree of the polynomial kernel function ('poly').\n        Ignored by all other kernels.\n\n    gamma : float, optional (default='auto')\n        Kernel coefficient for 'rbf', 'poly' and 'sigmoid'.\n\n        Current default is 'auto' which uses 1 / n_features,\n        if ``gamma='scale'`` is passed then it uses 1 / (n_features * X.std())\n        as value of gamma. The current default of gamma, 'auto', will change\n        to 'scale' in version 0.22. 'auto_deprecated', a deprecated version of\n        'auto' is used as a default indicating that no explicit value of gamma\n        was passed.\n\n    coef0 : float, optional (default=0.0)\n        Independent term in kernel function.\n        It is only significant in 'poly' and 'sigmoid'.\n\n    shrinking : boolean, optional (default=True)\n        Whether to use the shrinking heuristic.\n\n    probability : boolean, optional (default=False)\n        Whether to enable probability estimates. This must be enabled prior\n        to calling `fit`, and will slow down that method.\n\n    tol : float, optional (default=1e-3)\n        Tolerance for stopping criterion.\n\n    cache_size : float, optional\n        Specify the size of the kernel cache (in MB).\n\n    class_weight : {dict, 'balanced'}, optional\n        Set the parameter C of class i to class_weight[i]*C for\n        SVC. If not given, all classes are supposed to have\n        weight one. The \"balanced\" mode uses the values of y to automatically\n        adjust weights inversely proportional to class frequencies as\n        ``n_samples / (n_classes * np.bincount(y))``\n\n    verbose : bool, default: False\n        Enable verbose output. Note that this setting takes advantage of a\n        per-process runtime setting in libsvm that, if enabled, may not work\n        properly in a multithreaded context.\n\n    max_iter : int, optional (default=-1)\n        Hard limit on iterations within solver, or -1 for no limit.\n\n    decision_function_shape : 'ovo', 'ovr', default='ovr'\n        Whether to return a one-vs-rest ('ovr') decision function of shape\n        (n_samples, n_classes) as all other classifiers, or the original\n        one-vs-one ('ovo') decision function of libsvm which has shape\n        (n_samples, n_classes * (n_classes - 1) / 2).\n\n        .. versionchanged:: 0.19\n            decision_function_shape is 'ovr' by default.\n\n        .. versionadded:: 0.17\n           *decision_function_shape='ovr'* is recommended.\n\n        .. versionchanged:: 0.17\n           Deprecated *decision_function_shape='ovo' and None*.\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        The seed of the pseudo random number generator used when shuffling\n        the data for probability estimates. If int, random_state is the seed\n        used by the random number generator; If RandomState instance,\n        random_state is the random number generator; If None, the random\n        number generator is the RandomState instance used by `np.random`.\n\n    Attributes\n    ----------\n    support_ : array-like, shape = [n_SV]\n        Indices of support vectors.\n\n    support_vectors_ : array-like, shape = [n_SV, n_features]\n        Support vectors.\n\n    n_support_ : array-like, dtype=int32, shape = [n_class]\n        Number of support vectors for each class.\n\n    dual_coef_ : array, shape = [n_class-1, n_SV]\n        Coefficients of the support vector in the decision function.\n        For multiclass, coefficient for all 1-vs-1 classifiers.\n        The layout of the coefficients in the multiclass case is somewhat\n        non-trivial. See the section about multi-class classification in\n        the SVM section of the User Guide for details.\n\n    coef_ : array, shape = [n_class * (n_class-1) / 2, n_features]\n        Weights assigned to the features (coefficients in the primal\n        problem). This is only available in the case of a linear kernel.\n\n        `coef_` is readonly property derived from `dual_coef_` and\n        `support_vectors_`.\n\n    intercept_ : array, shape = [n_class * (n_class-1) / 2]\n        Constants in decision function.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> X = np.array([[-1, -1], [-2, -1], [1, 1], [2, 1]])\n    >>> y = np.array([1, 1, 2, 2])\n    >>> from sklearn.svm import NuSVC\n    >>> clf = NuSVC(gamma='scale')\n    >>> clf.fit(X, y) #doctest: +NORMALIZE_WHITESPACE\n    NuSVC(cache_size=200, class_weight=None, coef0=0.0,\n          decision_function_shape='ovr', degree=3, gamma='scale', kernel='rbf',\n          max_iter=-1, nu=0.5, probability=False, random_state=None,\n          shrinking=True, tol=0.001, verbose=False)\n    >>> print(clf.predict([[-0.8, -1]]))\n    [1]\n\n    See also\n    --------\n    SVC\n        Support Vector Machine for classification using libsvm.\n\n    LinearSVC\n        Scalable linear Support Vector Machine for classification using\n        liblinear.\n    "
        },
        {
            "classifier": "sklearn.svm.SVC",
            "name": "S V C",
            "default_values": [
                {
                    "key": "C",
                    "value": 1.0,
                    "type_": "float"
                },
                {
                    "key": "cache_size",
                    "value": 200,
                    "type_": "int"
                },
                {
                    "key": "coef0",
                    "value": 0.0,
                    "type_": "float"
                },
                {
                    "key": "decision_function_shape",
                    "value": "ovr",
                    "type_": "str"
                },
                {
                    "key": "degree",
                    "value": 3,
                    "type_": "int"
                },
                {
                    "key": "gamma",
                    "value": "auto_deprecated",
                    "type_": "str"
                },
                {
                    "key": "kernel",
                    "value": "rbf",
                    "type_": "str"
                },
                {
                    "key": "max_iter",
                    "value": -1,
                    "type_": "int"
                },
                {
                    "key": "probability",
                    "value": false,
                    "type_": "bool"
                },
                {
                    "key": "shrinking",
                    "value": true,
                    "type_": "bool"
                },
                {
                    "key": "tol",
                    "value": 0.001,
                    "type_": "float"
                },
                {
                    "key": "verbose",
                    "value": false,
                    "type_": "bool"
                }
            ],
            "doc_string": "C-Support Vector Classification.\n\n    The implementation is based on libsvm. The fit time complexity\n    is more than quadratic with the number of samples which makes it hard\n    to scale to dataset with more than a couple of 10000 samples.\n\n    The multiclass support is handled according to a one-vs-one scheme.\n\n    For details on the precise mathematical formulation of the provided\n    kernel functions and how `gamma`, `coef0` and `degree` affect each\n    other, see the corresponding section in the narrative documentation:\n    :ref:`svm_kernels`.\n\n    Read more in the :ref:`User Guide <svm_classification>`.\n\n    Parameters\n    ----------\n    C : float, optional (default=1.0)\n        Penalty parameter C of the error term.\n\n    kernel : string, optional (default='rbf')\n        Specifies the kernel type to be used in the algorithm.\n        It must be one of 'linear', 'poly', 'rbf', 'sigmoid', 'precomputed' or\n        a callable.\n        If none is given, 'rbf' will be used. If a callable is given it is\n        used to pre-compute the kernel matrix from data matrices; that matrix\n        should be an array of shape ``(n_samples, n_samples)``.\n\n    degree : int, optional (default=3)\n        Degree of the polynomial kernel function ('poly').\n        Ignored by all other kernels.\n\n    gamma : float, optional (default='auto')\n        Kernel coefficient for 'rbf', 'poly' and 'sigmoid'.\n\n        Current default is 'auto' which uses 1 / n_features,\n        if ``gamma='scale'`` is passed then it uses 1 / (n_features * X.std())\n        as value of gamma. The current default of gamma, 'auto', will change\n        to 'scale' in version 0.22. 'auto_deprecated', a deprecated version of\n        'auto' is used as a default indicating that no explicit value of gamma\n        was passed.\n\n    coef0 : float, optional (default=0.0)\n        Independent term in kernel function.\n        It is only significant in 'poly' and 'sigmoid'.\n\n    shrinking : boolean, optional (default=True)\n        Whether to use the shrinking heuristic.\n\n    probability : boolean, optional (default=False)\n        Whether to enable probability estimates. This must be enabled prior\n        to calling `fit`, and will slow down that method.\n\n    tol : float, optional (default=1e-3)\n        Tolerance for stopping criterion.\n\n    cache_size : float, optional\n        Specify the size of the kernel cache (in MB).\n\n    class_weight : {dict, 'balanced'}, optional\n        Set the parameter C of class i to class_weight[i]*C for\n        SVC. If not given, all classes are supposed to have\n        weight one.\n        The \"balanced\" mode uses the values of y to automatically adjust\n        weights inversely proportional to class frequencies in the input data\n        as ``n_samples / (n_classes * np.bincount(y))``\n\n    verbose : bool, default: False\n        Enable verbose output. Note that this setting takes advantage of a\n        per-process runtime setting in libsvm that, if enabled, may not work\n        properly in a multithreaded context.\n\n    max_iter : int, optional (default=-1)\n        Hard limit on iterations within solver, or -1 for no limit.\n\n    decision_function_shape : 'ovo', 'ovr', default='ovr'\n        Whether to return a one-vs-rest ('ovr') decision function of shape\n        (n_samples, n_classes) as all other classifiers, or the original\n        one-vs-one ('ovo') decision function of libsvm which has shape\n        (n_samples, n_classes * (n_classes - 1) / 2). However, one-vs-one\n        ('ovo') is always used as multi-class strategy.\n\n        .. versionchanged:: 0.19\n            decision_function_shape is 'ovr' by default.\n\n        .. versionadded:: 0.17\n           *decision_function_shape='ovr'* is recommended.\n\n        .. versionchanged:: 0.17\n           Deprecated *decision_function_shape='ovo' and None*.\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        The seed of the pseudo random number generator used when shuffling\n        the data for probability estimates. If int, random_state is the\n        seed used by the random number generator; If RandomState instance,\n        random_state is the random number generator; If None, the random\n        number generator is the RandomState instance used by `np.random`.\n\n    Attributes\n    ----------\n    support_ : array-like, shape = [n_SV]\n        Indices of support vectors.\n\n    support_vectors_ : array-like, shape = [n_SV, n_features]\n        Support vectors.\n\n    n_support_ : array-like, dtype=int32, shape = [n_class]\n        Number of support vectors for each class.\n\n    dual_coef_ : array, shape = [n_class-1, n_SV]\n        Coefficients of the support vector in the decision function.\n        For multiclass, coefficient for all 1-vs-1 classifiers.\n        The layout of the coefficients in the multiclass case is somewhat\n        non-trivial. See the section about multi-class classification in the\n        SVM section of the User Guide for details.\n\n    coef_ : array, shape = [n_class * (n_class-1) / 2, n_features]\n        Weights assigned to the features (coefficients in the primal\n        problem). This is only available in the case of a linear kernel.\n\n        `coef_` is a readonly property derived from `dual_coef_` and\n        `support_vectors_`.\n\n    intercept_ : array, shape = [n_class * (n_class-1) / 2]\n        Constants in decision function.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> X = np.array([[-1, -1], [-2, -1], [1, 1], [2, 1]])\n    >>> y = np.array([1, 1, 2, 2])\n    >>> from sklearn.svm import SVC\n    >>> clf = SVC(gamma='auto')\n    >>> clf.fit(X, y) #doctest: +NORMALIZE_WHITESPACE\n    SVC(C=1.0, cache_size=200, class_weight=None, coef0=0.0,\n        decision_function_shape='ovr', degree=3, gamma='auto', kernel='rbf',\n        max_iter=-1, probability=False, random_state=None, shrinking=True,\n        tol=0.001, verbose=False)\n    >>> print(clf.predict([[-0.8, -1]]))\n    [1]\n\n    See also\n    --------\n    SVR\n        Support Vector Machine for Regression implemented using libsvm.\n\n    LinearSVC\n        Scalable Linear Support Vector Machine for classification\n        implemented using liblinear. Check the See also section of\n        LinearSVC for more comparison element.\n\n    "
        },
        {
            "classifier": "sklearn.tree.DecisionTreeClassifier",
            "name": "Decision Tree Classifier",
            "default_values": [
                {
                    "key": "criterion",
                    "value": "gini",
                    "type_": "str"
                },
                {
                    "key": "min_impurity_decrease",
                    "value": 0.0,
                    "type_": "float"
                },
                {
                    "key": "min_samples_leaf",
                    "value": 1,
                    "type_": "int"
                },
                {
                    "key": "min_samples_split",
                    "value": 2,
                    "type_": "int"
                },
                {
                    "key": "min_weight_fraction_leaf",
                    "value": 0.0,
                    "type_": "float"
                },
                {
                    "key": "presort",
                    "value": false,
                    "type_": "bool"
                },
                {
                    "key": "splitter",
                    "value": "best",
                    "type_": "str"
                }
            ],
            "doc_string": "A decision tree classifier.\n\n    Read more in the :ref:`User Guide <tree>`.\n\n    Parameters\n    ----------\n    criterion : string, optional (default=\"gini\")\n        The function to measure the quality of a split. Supported criteria are\n        \"gini\" for the Gini impurity and \"entropy\" for the information gain.\n\n    splitter : string, optional (default=\"best\")\n        The strategy used to choose the split at each node. Supported\n        strategies are \"best\" to choose the best split and \"random\" to choose\n        the best random split.\n\n    max_depth : int or None, optional (default=None)\n        The maximum depth of the tree. If None, then nodes are expanded until\n        all leaves are pure or until all leaves contain less than\n        min_samples_split samples.\n\n    min_samples_split : int, float, optional (default=2)\n        The minimum number of samples required to split an internal node:\n\n        - If int, then consider `min_samples_split` as the minimum number.\n        - If float, then `min_samples_split` is a fraction and\n          `ceil(min_samples_split * n_samples)` are the minimum\n          number of samples for each split.\n\n        .. versionchanged:: 0.18\n           Added float values for fractions.\n\n    min_samples_leaf : int, float, optional (default=1)\n        The minimum number of samples required to be at a leaf node.\n        A split point at any depth will only be considered if it leaves at\n        least ``min_samples_leaf`` training samples in each of the left and\n        right branches.  This may have the effect of smoothing the model,\n        especially in regression.\n\n        - If int, then consider `min_samples_leaf` as the minimum number.\n        - If float, then `min_samples_leaf` is a fraction and\n          `ceil(min_samples_leaf * n_samples)` are the minimum\n          number of samples for each node.\n\n        .. versionchanged:: 0.18\n           Added float values for fractions.\n\n    min_weight_fraction_leaf : float, optional (default=0.)\n        The minimum weighted fraction of the sum total of weights (of all\n        the input samples) required to be at a leaf node. Samples have\n        equal weight when sample_weight is not provided.\n\n    max_features : int, float, string or None, optional (default=None)\n        The number of features to consider when looking for the best split:\n\n            - If int, then consider `max_features` features at each split.\n            - If float, then `max_features` is a fraction and\n              `int(max_features * n_features)` features are considered at each\n              split.\n            - If \"auto\", then `max_features=sqrt(n_features)`.\n            - If \"sqrt\", then `max_features=sqrt(n_features)`.\n            - If \"log2\", then `max_features=log2(n_features)`.\n            - If None, then `max_features=n_features`.\n\n        Note: the search for a split does not stop until at least one\n        valid partition of the node samples is found, even if it requires to\n        effectively inspect more than ``max_features`` features.\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    max_leaf_nodes : int or None, optional (default=None)\n        Grow a tree with ``max_leaf_nodes`` in best-first fashion.\n        Best nodes are defined as relative reduction in impurity.\n        If None then unlimited number of leaf nodes.\n\n    min_impurity_decrease : float, optional (default=0.)\n        A node will be split if this split induces a decrease of the impurity\n        greater than or equal to this value.\n\n        The weighted impurity decrease equation is the following::\n\n            N_t / N * (impurity - N_t_R / N_t * right_impurity\n                                - N_t_L / N_t * left_impurity)\n\n        where ``N`` is the total number of samples, ``N_t`` is the number of\n        samples at the current node, ``N_t_L`` is the number of samples in the\n        left child, and ``N_t_R`` is the number of samples in the right child.\n\n        ``N``, ``N_t``, ``N_t_R`` and ``N_t_L`` all refer to the weighted sum,\n        if ``sample_weight`` is passed.\n\n        .. versionadded:: 0.19\n\n    min_impurity_split : float,\n        Threshold for early stopping in tree growth. A node will split\n        if its impurity is above the threshold, otherwise it is a leaf.\n\n        .. deprecated:: 0.19\n           ``min_impurity_split`` has been deprecated in favor of\n           ``min_impurity_decrease`` in 0.19 and will be removed in 0.21.\n           Use ``min_impurity_decrease`` instead.\n\n    class_weight : dict, list of dicts, \"balanced\" or None, default=None\n        Weights associated with classes in the form ``{class_label: weight}``.\n        If not given, all classes are supposed to have weight one. For\n        multi-output problems, a list of dicts can be provided in the same\n        order as the columns of y.\n\n        Note that for multioutput (including multilabel) weights should be\n        defined for each class of every column in its own dict. For example,\n        for four-class multilabel classification weights should be\n        [{0: 1, 1: 1}, {0: 1, 1: 5}, {0: 1, 1: 1}, {0: 1, 1: 1}] instead of\n        [{1:1}, {2:5}, {3:1}, {4:1}].\n\n        The \"balanced\" mode uses the values of y to automatically adjust\n        weights inversely proportional to class frequencies in the input data\n        as ``n_samples / (n_classes * np.bincount(y))``\n\n        For multi-output, the weights of each column of y will be multiplied.\n\n        Note that these weights will be multiplied with sample_weight (passed\n        through the fit method) if sample_weight is specified.\n\n    presort : bool, optional (default=False)\n        Whether to presort the data to speed up the finding of best splits in\n        fitting. For the default settings of a decision tree on large\n        datasets, setting this to true may slow down the training process.\n        When using either a smaller dataset or a restricted depth, this may\n        speed up the training.\n\n    Attributes\n    ----------\n    classes_ : array of shape = [n_classes] or a list of such arrays\n        The classes labels (single output problem),\n        or a list of arrays of class labels (multi-output problem).\n\n    feature_importances_ : array of shape = [n_features]\n        The feature importances. The higher, the more important the\n        feature. The importance of a feature is computed as the (normalized)\n        total reduction of the criterion brought by that feature.  It is also\n        known as the Gini importance [4]_.\n\n    max_features_ : int,\n        The inferred value of max_features.\n\n    n_classes_ : int or list\n        The number of classes (for single output problems),\n        or a list containing the number of classes for each\n        output (for multi-output problems).\n\n    n_features_ : int\n        The number of features when ``fit`` is performed.\n\n    n_outputs_ : int\n        The number of outputs when ``fit`` is performed.\n\n    tree_ : Tree object\n        The underlying Tree object. Please refer to\n        ``help(sklearn.tree._tree.Tree)`` for attributes of Tree object and\n        :ref:`sphx_glr_auto_examples_tree_plot_unveil_tree_structure.py`\n        for basic usage of these attributes.\n\n    Notes\n    -----\n    The default values for the parameters controlling the size of the trees\n    (e.g. ``max_depth``, ``min_samples_leaf``, etc.) lead to fully grown and\n    unpruned trees which can potentially be very large on some data sets. To\n    reduce memory consumption, the complexity and size of the trees should be\n    controlled by setting those parameter values.\n\n    The features are always randomly permuted at each split. Therefore,\n    the best found split may vary, even with the same training data and\n    ``max_features=n_features``, if the improvement of the criterion is\n    identical for several splits enumerated during the search of the best\n    split. To obtain a deterministic behaviour during fitting,\n    ``random_state`` has to be fixed.\n\n    See also\n    --------\n    DecisionTreeRegressor\n\n    References\n    ----------\n\n    .. [1] https://en.wikipedia.org/wiki/Decision_tree_learning\n\n    .. [2] L. Breiman, J. Friedman, R. Olshen, and C. Stone, \"Classification\n           and Regression Trees\", Wadsworth, Belmont, CA, 1984.\n\n    .. [3] T. Hastie, R. Tibshirani and J. Friedman. \"Elements of Statistical\n           Learning\", Springer, 2009.\n\n    .. [4] L. Breiman, and A. Cutler, \"Random Forests\",\n           http://www.stat.berkeley.edu/~breiman/RandomForests/cc_home.htm\n\n    Examples\n    --------\n    >>> from sklearn.datasets import load_iris\n    >>> from sklearn.model_selection import cross_val_score\n    >>> from sklearn.tree import DecisionTreeClassifier\n    >>> clf = DecisionTreeClassifier(random_state=0)\n    >>> iris = load_iris()\n    >>> cross_val_score(clf, iris.data, iris.target, cv=10)\n    ...                             # doctest: +SKIP\n    ...\n    array([ 1.     ,  0.93...,  0.86...,  0.93...,  0.93...,\n            0.93...,  0.93...,  1.     ,  0.93...,  1.      ])\n    "
        },
        {
            "classifier": "sklearn.tree.ExtraTreeClassifier",
            "name": "Extra Tree Classifier",
            "default_values": [
                {
                    "key": "criterion",
                    "value": "gini",
                    "type_": "str"
                },
                {
                    "key": "max_features",
                    "value": "auto",
                    "type_": "str"
                },
                {
                    "key": "min_impurity_decrease",
                    "value": 0.0,
                    "type_": "float"
                },
                {
                    "key": "min_samples_leaf",
                    "value": 1,
                    "type_": "int"
                },
                {
                    "key": "min_samples_split",
                    "value": 2,
                    "type_": "int"
                },
                {
                    "key": "min_weight_fraction_leaf",
                    "value": 0.0,
                    "type_": "float"
                },
                {
                    "key": "splitter",
                    "value": "random",
                    "type_": "str"
                }
            ],
            "doc_string": "An extremely randomized tree classifier.\n\n    Extra-trees differ from classic decision trees in the way they are built.\n    When looking for the best split to separate the samples of a node into two\n    groups, random splits are drawn for each of the `max_features` randomly\n    selected features and the best split among those is chosen. When\n    `max_features` is set 1, this amounts to building a totally random\n    decision tree.\n\n    Warning: Extra-trees should only be used within ensemble methods.\n\n    Read more in the :ref:`User Guide <tree>`.\n\n    Parameters\n    ----------\n    criterion : string, optional (default=\"gini\")\n        The function to measure the quality of a split. Supported criteria are\n        \"gini\" for the Gini impurity and \"entropy\" for the information gain.\n\n    splitter : string, optional (default=\"random\")\n        The strategy used to choose the split at each node. Supported\n        strategies are \"best\" to choose the best split and \"random\" to choose\n        the best random split.\n\n    max_depth : int or None, optional (default=None)\n        The maximum depth of the tree. If None, then nodes are expanded until\n        all leaves are pure or until all leaves contain less than\n        min_samples_split samples.\n\n    min_samples_split : int, float, optional (default=2)\n        The minimum number of samples required to split an internal node:\n\n        - If int, then consider `min_samples_split` as the minimum number.\n        - If float, then `min_samples_split` is a fraction and\n          `ceil(min_samples_split * n_samples)` are the minimum\n          number of samples for each split.\n\n        .. versionchanged:: 0.18\n           Added float values for fractions.\n\n    min_samples_leaf : int, float, optional (default=1)\n        The minimum number of samples required to be at a leaf node.\n        A split point at any depth will only be considered if it leaves at\n        least ``min_samples_leaf`` training samples in each of the left and\n        right branches.  This may have the effect of smoothing the model,\n        especially in regression.\n\n        - If int, then consider `min_samples_leaf` as the minimum number.\n        - If float, then `min_samples_leaf` is a fraction and\n          `ceil(min_samples_leaf * n_samples)` are the minimum\n          number of samples for each node.\n\n        .. versionchanged:: 0.18\n           Added float values for fractions.\n\n    min_weight_fraction_leaf : float, optional (default=0.)\n        The minimum weighted fraction of the sum total of weights (of all\n        the input samples) required to be at a leaf node. Samples have\n        equal weight when sample_weight is not provided.\n\n    max_features : int, float, string or None, optional (default=\"auto\")\n        The number of features to consider when looking for the best split:\n\n            - If int, then consider `max_features` features at each split.\n            - If float, then `max_features` is a fraction and\n              `int(max_features * n_features)` features are considered at each\n              split.\n            - If \"auto\", then `max_features=sqrt(n_features)`.\n            - If \"sqrt\", then `max_features=sqrt(n_features)`.\n            - If \"log2\", then `max_features=log2(n_features)`.\n            - If None, then `max_features=n_features`.\n\n        Note: the search for a split does not stop until at least one\n        valid partition of the node samples is found, even if it requires to\n        effectively inspect more than ``max_features`` features.\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    max_leaf_nodes : int or None, optional (default=None)\n        Grow a tree with ``max_leaf_nodes`` in best-first fashion.\n        Best nodes are defined as relative reduction in impurity.\n        If None then unlimited number of leaf nodes.\n\n    min_impurity_decrease : float, optional (default=0.)\n        A node will be split if this split induces a decrease of the impurity\n        greater than or equal to this value.\n\n        The weighted impurity decrease equation is the following::\n\n            N_t / N * (impurity - N_t_R / N_t * right_impurity\n                                - N_t_L / N_t * left_impurity)\n\n        where ``N`` is the total number of samples, ``N_t`` is the number of\n        samples at the current node, ``N_t_L`` is the number of samples in the\n        left child, and ``N_t_R`` is the number of samples in the right child.\n\n        ``N``, ``N_t``, ``N_t_R`` and ``N_t_L`` all refer to the weighted sum,\n        if ``sample_weight`` is passed.\n\n        .. versionadded:: 0.19\n\n    min_impurity_split : float,\n        Threshold for early stopping in tree growth. A node will split\n        if its impurity is above the threshold, otherwise it is a leaf.\n\n        .. deprecated:: 0.19\n           ``min_impurity_split`` has been deprecated in favor of\n           ``min_impurity_decrease`` in 0.19 and will be removed in 0.21.\n           Use ``min_impurity_decrease`` instead.\n\n    class_weight : dict, list of dicts, \"balanced\" or None, default=None\n        Weights associated with classes in the form ``{class_label: weight}``.\n        If not given, all classes are supposed to have weight one. For\n        multi-output problems, a list of dicts can be provided in the same\n        order as the columns of y.\n\n        Note that for multioutput (including multilabel) weights should be\n        defined for each class of every column in its own dict. For example,\n        for four-class multilabel classification weights should be\n        [{0: 1, 1: 1}, {0: 1, 1: 5}, {0: 1, 1: 1}, {0: 1, 1: 1}] instead of\n        [{1:1}, {2:5}, {3:1}, {4:1}].\n\n        The \"balanced\" mode uses the values of y to automatically adjust\n        weights inversely proportional to class frequencies in the input data\n        as ``n_samples / (n_classes * np.bincount(y))``\n\n        For multi-output, the weights of each column of y will be multiplied.\n\n        Note that these weights will be multiplied with sample_weight (passed\n        through the fit method) if sample_weight is specified.\n\n    See also\n    --------\n    ExtraTreeRegressor, sklearn.ensemble.ExtraTreesClassifier,\n    sklearn.ensemble.ExtraTreesRegressor\n\n    Notes\n    -----\n    The default values for the parameters controlling the size of the trees\n    (e.g. ``max_depth``, ``min_samples_leaf``, etc.) lead to fully grown and\n    unpruned trees which can potentially be very large on some data sets. To\n    reduce memory consumption, the complexity and size of the trees should be\n    controlled by setting those parameter values.\n\n    References\n    ----------\n\n    .. [1] P. Geurts, D. Ernst., and L. Wehenkel, \"Extremely randomized trees\",\n           Machine Learning, 63(1), 3-42, 2006.\n    "
        },
        {
            "classifier": "sklearn.ensemble.bagging.BaggingClassifier",
            "name": "Bagging Classifier",
            "default_values": [
                {
                    "key": "bootstrap",
                    "value": true,
                    "type_": "bool"
                },
                {
                    "key": "bootstrap_features",
                    "value": false,
                    "type_": "bool"
                },
                {
                    "key": "max_features",
                    "value": 1.0,
                    "type_": "float"
                },
                {
                    "key": "max_samples",
                    "value": 1.0,
                    "type_": "float"
                },
                {
                    "key": "n_estimators",
                    "value": 10,
                    "type_": "int"
                },
                {
                    "key": "oob_score",
                    "value": false,
                    "type_": "bool"
                },
                {
                    "key": "verbose",
                    "value": 0,
                    "type_": "int"
                },
                {
                    "key": "warm_start",
                    "value": false,
                    "type_": "bool"
                }
            ],
            "doc_string": "A Bagging classifier.\n\n    A Bagging classifier is an ensemble meta-estimator that fits base\n    classifiers each on random subsets of the original dataset and then\n    aggregate their individual predictions (either by voting or by averaging)\n    to form a final prediction. Such a meta-estimator can typically be used as\n    a way to reduce the variance of a black-box estimator (e.g., a decision\n    tree), by introducing randomization into its construction procedure and\n    then making an ensemble out of it.\n\n    This algorithm encompasses several works from the literature. When random\n    subsets of the dataset are drawn as random subsets of the samples, then\n    this algorithm is known as Pasting [1]_. If samples are drawn with\n    replacement, then the method is known as Bagging [2]_. When random subsets\n    of the dataset are drawn as random subsets of the features, then the method\n    is known as Random Subspaces [3]_. Finally, when base estimators are built\n    on subsets of both samples and features, then the method is known as\n    Random Patches [4]_.\n\n    Read more in the :ref:`User Guide <bagging>`.\n\n    Parameters\n    ----------\n    base_estimator : object or None, optional (default=None)\n        The base estimator to fit on random subsets of the dataset.\n        If None, then the base estimator is a decision tree.\n\n    n_estimators : int, optional (default=10)\n        The number of base estimators in the ensemble.\n\n    max_samples : int or float, optional (default=1.0)\n        The number of samples to draw from X to train each base estimator.\n\n        - If int, then draw `max_samples` samples.\n        - If float, then draw `max_samples * X.shape[0]` samples.\n\n    max_features : int or float, optional (default=1.0)\n        The number of features to draw from X to train each base estimator.\n\n        - If int, then draw `max_features` features.\n        - If float, then draw `max_features * X.shape[1]` features.\n\n    bootstrap : boolean, optional (default=True)\n        Whether samples are drawn with replacement.\n\n    bootstrap_features : boolean, optional (default=False)\n        Whether features are drawn with replacement.\n\n    oob_score : bool, optional (default=False)\n        Whether to use out-of-bag samples to estimate\n        the generalization error.\n\n    warm_start : bool, optional (default=False)\n        When set to True, reuse the solution of the previous call to fit\n        and add more estimators to the ensemble, otherwise, just fit\n        a whole new ensemble. See :term:`the Glossary <warm_start>`.\n\n        .. versionadded:: 0.17\n           *warm_start* constructor parameter.\n\n    n_jobs : int or None, optional (default=None)\n        The number of jobs to run in parallel for both `fit` and `predict`.\n        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n        ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n        for more details.\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    verbose : int, optional (default=0)\n        Controls the verbosity when fitting and predicting.\n\n    Attributes\n    ----------\n    base_estimator_ : estimator\n        The base estimator from which the ensemble is grown.\n\n    estimators_ : list of estimators\n        The collection of fitted base estimators.\n\n    estimators_samples_ : list of arrays\n        The subset of drawn samples (i.e., the in-bag samples) for each base\n        estimator. Each subset is defined by an array of the indices selected.\n\n    estimators_features_ : list of arrays\n        The subset of drawn features for each base estimator.\n\n    classes_ : array of shape = [n_classes]\n        The classes labels.\n\n    n_classes_ : int or list\n        The number of classes.\n\n    oob_score_ : float\n        Score of the training dataset obtained using an out-of-bag estimate.\n\n    oob_decision_function_ : array of shape = [n_samples, n_classes]\n        Decision function computed with out-of-bag estimate on the training\n        set. If n_estimators is small it might be possible that a data point\n        was never left out during the bootstrap. In this case,\n        `oob_decision_function_` might contain NaN.\n\n    References\n    ----------\n\n    .. [1] L. Breiman, \"Pasting small votes for classification in large\n           databases and on-line\", Machine Learning, 36(1), 85-103, 1999.\n\n    .. [2] L. Breiman, \"Bagging predictors\", Machine Learning, 24(2), 123-140,\n           1996.\n\n    .. [3] T. Ho, \"The random subspace method for constructing decision\n           forests\", Pattern Analysis and Machine Intelligence, 20(8), 832-844,\n           1998.\n\n    .. [4] G. Louppe and P. Geurts, \"Ensembles on Random Patches\", Machine\n           Learning and Knowledge Discovery in Databases, 346-361, 2012.\n    "
        },
        {
            "classifier": "sklearn.ensemble.bagging.DecisionTreeClassifier",
            "name": "Decision Tree Classifier",
            "default_values": [
                {
                    "key": "criterion",
                    "value": "gini",
                    "type_": "str"
                },
                {
                    "key": "min_impurity_decrease",
                    "value": 0.0,
                    "type_": "float"
                },
                {
                    "key": "min_samples_leaf",
                    "value": 1,
                    "type_": "int"
                },
                {
                    "key": "min_samples_split",
                    "value": 2,
                    "type_": "int"
                },
                {
                    "key": "min_weight_fraction_leaf",
                    "value": 0.0,
                    "type_": "float"
                },
                {
                    "key": "presort",
                    "value": false,
                    "type_": "bool"
                },
                {
                    "key": "splitter",
                    "value": "best",
                    "type_": "str"
                }
            ],
            "doc_string": "A decision tree classifier.\n\n    Read more in the :ref:`User Guide <tree>`.\n\n    Parameters\n    ----------\n    criterion : string, optional (default=\"gini\")\n        The function to measure the quality of a split. Supported criteria are\n        \"gini\" for the Gini impurity and \"entropy\" for the information gain.\n\n    splitter : string, optional (default=\"best\")\n        The strategy used to choose the split at each node. Supported\n        strategies are \"best\" to choose the best split and \"random\" to choose\n        the best random split.\n\n    max_depth : int or None, optional (default=None)\n        The maximum depth of the tree. If None, then nodes are expanded until\n        all leaves are pure or until all leaves contain less than\n        min_samples_split samples.\n\n    min_samples_split : int, float, optional (default=2)\n        The minimum number of samples required to split an internal node:\n\n        - If int, then consider `min_samples_split` as the minimum number.\n        - If float, then `min_samples_split` is a fraction and\n          `ceil(min_samples_split * n_samples)` are the minimum\n          number of samples for each split.\n\n        .. versionchanged:: 0.18\n           Added float values for fractions.\n\n    min_samples_leaf : int, float, optional (default=1)\n        The minimum number of samples required to be at a leaf node.\n        A split point at any depth will only be considered if it leaves at\n        least ``min_samples_leaf`` training samples in each of the left and\n        right branches.  This may have the effect of smoothing the model,\n        especially in regression.\n\n        - If int, then consider `min_samples_leaf` as the minimum number.\n        - If float, then `min_samples_leaf` is a fraction and\n          `ceil(min_samples_leaf * n_samples)` are the minimum\n          number of samples for each node.\n\n        .. versionchanged:: 0.18\n           Added float values for fractions.\n\n    min_weight_fraction_leaf : float, optional (default=0.)\n        The minimum weighted fraction of the sum total of weights (of all\n        the input samples) required to be at a leaf node. Samples have\n        equal weight when sample_weight is not provided.\n\n    max_features : int, float, string or None, optional (default=None)\n        The number of features to consider when looking for the best split:\n\n            - If int, then consider `max_features` features at each split.\n            - If float, then `max_features` is a fraction and\n              `int(max_features * n_features)` features are considered at each\n              split.\n            - If \"auto\", then `max_features=sqrt(n_features)`.\n            - If \"sqrt\", then `max_features=sqrt(n_features)`.\n            - If \"log2\", then `max_features=log2(n_features)`.\n            - If None, then `max_features=n_features`.\n\n        Note: the search for a split does not stop until at least one\n        valid partition of the node samples is found, even if it requires to\n        effectively inspect more than ``max_features`` features.\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    max_leaf_nodes : int or None, optional (default=None)\n        Grow a tree with ``max_leaf_nodes`` in best-first fashion.\n        Best nodes are defined as relative reduction in impurity.\n        If None then unlimited number of leaf nodes.\n\n    min_impurity_decrease : float, optional (default=0.)\n        A node will be split if this split induces a decrease of the impurity\n        greater than or equal to this value.\n\n        The weighted impurity decrease equation is the following::\n\n            N_t / N * (impurity - N_t_R / N_t * right_impurity\n                                - N_t_L / N_t * left_impurity)\n\n        where ``N`` is the total number of samples, ``N_t`` is the number of\n        samples at the current node, ``N_t_L`` is the number of samples in the\n        left child, and ``N_t_R`` is the number of samples in the right child.\n\n        ``N``, ``N_t``, ``N_t_R`` and ``N_t_L`` all refer to the weighted sum,\n        if ``sample_weight`` is passed.\n\n        .. versionadded:: 0.19\n\n    min_impurity_split : float,\n        Threshold for early stopping in tree growth. A node will split\n        if its impurity is above the threshold, otherwise it is a leaf.\n\n        .. deprecated:: 0.19\n           ``min_impurity_split`` has been deprecated in favor of\n           ``min_impurity_decrease`` in 0.19 and will be removed in 0.21.\n           Use ``min_impurity_decrease`` instead.\n\n    class_weight : dict, list of dicts, \"balanced\" or None, default=None\n        Weights associated with classes in the form ``{class_label: weight}``.\n        If not given, all classes are supposed to have weight one. For\n        multi-output problems, a list of dicts can be provided in the same\n        order as the columns of y.\n\n        Note that for multioutput (including multilabel) weights should be\n        defined for each class of every column in its own dict. For example,\n        for four-class multilabel classification weights should be\n        [{0: 1, 1: 1}, {0: 1, 1: 5}, {0: 1, 1: 1}, {0: 1, 1: 1}] instead of\n        [{1:1}, {2:5}, {3:1}, {4:1}].\n\n        The \"balanced\" mode uses the values of y to automatically adjust\n        weights inversely proportional to class frequencies in the input data\n        as ``n_samples / (n_classes * np.bincount(y))``\n\n        For multi-output, the weights of each column of y will be multiplied.\n\n        Note that these weights will be multiplied with sample_weight (passed\n        through the fit method) if sample_weight is specified.\n\n    presort : bool, optional (default=False)\n        Whether to presort the data to speed up the finding of best splits in\n        fitting. For the default settings of a decision tree on large\n        datasets, setting this to true may slow down the training process.\n        When using either a smaller dataset or a restricted depth, this may\n        speed up the training.\n\n    Attributes\n    ----------\n    classes_ : array of shape = [n_classes] or a list of such arrays\n        The classes labels (single output problem),\n        or a list of arrays of class labels (multi-output problem).\n\n    feature_importances_ : array of shape = [n_features]\n        The feature importances. The higher, the more important the\n        feature. The importance of a feature is computed as the (normalized)\n        total reduction of the criterion brought by that feature.  It is also\n        known as the Gini importance [4]_.\n\n    max_features_ : int,\n        The inferred value of max_features.\n\n    n_classes_ : int or list\n        The number of classes (for single output problems),\n        or a list containing the number of classes for each\n        output (for multi-output problems).\n\n    n_features_ : int\n        The number of features when ``fit`` is performed.\n\n    n_outputs_ : int\n        The number of outputs when ``fit`` is performed.\n\n    tree_ : Tree object\n        The underlying Tree object. Please refer to\n        ``help(sklearn.tree._tree.Tree)`` for attributes of Tree object and\n        :ref:`sphx_glr_auto_examples_tree_plot_unveil_tree_structure.py`\n        for basic usage of these attributes.\n\n    Notes\n    -----\n    The default values for the parameters controlling the size of the trees\n    (e.g. ``max_depth``, ``min_samples_leaf``, etc.) lead to fully grown and\n    unpruned trees which can potentially be very large on some data sets. To\n    reduce memory consumption, the complexity and size of the trees should be\n    controlled by setting those parameter values.\n\n    The features are always randomly permuted at each split. Therefore,\n    the best found split may vary, even with the same training data and\n    ``max_features=n_features``, if the improvement of the criterion is\n    identical for several splits enumerated during the search of the best\n    split. To obtain a deterministic behaviour during fitting,\n    ``random_state`` has to be fixed.\n\n    See also\n    --------\n    DecisionTreeRegressor\n\n    References\n    ----------\n\n    .. [1] https://en.wikipedia.org/wiki/Decision_tree_learning\n\n    .. [2] L. Breiman, J. Friedman, R. Olshen, and C. Stone, \"Classification\n           and Regression Trees\", Wadsworth, Belmont, CA, 1984.\n\n    .. [3] T. Hastie, R. Tibshirani and J. Friedman. \"Elements of Statistical\n           Learning\", Springer, 2009.\n\n    .. [4] L. Breiman, and A. Cutler, \"Random Forests\",\n           http://www.stat.berkeley.edu/~breiman/RandomForests/cc_home.htm\n\n    Examples\n    --------\n    >>> from sklearn.datasets import load_iris\n    >>> from sklearn.model_selection import cross_val_score\n    >>> from sklearn.tree import DecisionTreeClassifier\n    >>> clf = DecisionTreeClassifier(random_state=0)\n    >>> iris = load_iris()\n    >>> cross_val_score(clf, iris.data, iris.target, cv=10)\n    ...                             # doctest: +SKIP\n    ...\n    array([ 1.     ,  0.93...,  0.86...,  0.93...,  0.93...,\n            0.93...,  0.93...,  1.     ,  0.93...,  1.      ])\n    "
        },
        {
            "classifier": "sklearn.ensemble.forest.DecisionTreeClassifier",
            "name": "Decision Tree Classifier",
            "default_values": [
                {
                    "key": "criterion",
                    "value": "gini",
                    "type_": "str"
                },
                {
                    "key": "min_impurity_decrease",
                    "value": 0.0,
                    "type_": "float"
                },
                {
                    "key": "min_samples_leaf",
                    "value": 1,
                    "type_": "int"
                },
                {
                    "key": "min_samples_split",
                    "value": 2,
                    "type_": "int"
                },
                {
                    "key": "min_weight_fraction_leaf",
                    "value": 0.0,
                    "type_": "float"
                },
                {
                    "key": "presort",
                    "value": false,
                    "type_": "bool"
                },
                {
                    "key": "splitter",
                    "value": "best",
                    "type_": "str"
                }
            ],
            "doc_string": "A decision tree classifier.\n\n    Read more in the :ref:`User Guide <tree>`.\n\n    Parameters\n    ----------\n    criterion : string, optional (default=\"gini\")\n        The function to measure the quality of a split. Supported criteria are\n        \"gini\" for the Gini impurity and \"entropy\" for the information gain.\n\n    splitter : string, optional (default=\"best\")\n        The strategy used to choose the split at each node. Supported\n        strategies are \"best\" to choose the best split and \"random\" to choose\n        the best random split.\n\n    max_depth : int or None, optional (default=None)\n        The maximum depth of the tree. If None, then nodes are expanded until\n        all leaves are pure or until all leaves contain less than\n        min_samples_split samples.\n\n    min_samples_split : int, float, optional (default=2)\n        The minimum number of samples required to split an internal node:\n\n        - If int, then consider `min_samples_split` as the minimum number.\n        - If float, then `min_samples_split` is a fraction and\n          `ceil(min_samples_split * n_samples)` are the minimum\n          number of samples for each split.\n\n        .. versionchanged:: 0.18\n           Added float values for fractions.\n\n    min_samples_leaf : int, float, optional (default=1)\n        The minimum number of samples required to be at a leaf node.\n        A split point at any depth will only be considered if it leaves at\n        least ``min_samples_leaf`` training samples in each of the left and\n        right branches.  This may have the effect of smoothing the model,\n        especially in regression.\n\n        - If int, then consider `min_samples_leaf` as the minimum number.\n        - If float, then `min_samples_leaf` is a fraction and\n          `ceil(min_samples_leaf * n_samples)` are the minimum\n          number of samples for each node.\n\n        .. versionchanged:: 0.18\n           Added float values for fractions.\n\n    min_weight_fraction_leaf : float, optional (default=0.)\n        The minimum weighted fraction of the sum total of weights (of all\n        the input samples) required to be at a leaf node. Samples have\n        equal weight when sample_weight is not provided.\n\n    max_features : int, float, string or None, optional (default=None)\n        The number of features to consider when looking for the best split:\n\n            - If int, then consider `max_features` features at each split.\n            - If float, then `max_features` is a fraction and\n              `int(max_features * n_features)` features are considered at each\n              split.\n            - If \"auto\", then `max_features=sqrt(n_features)`.\n            - If \"sqrt\", then `max_features=sqrt(n_features)`.\n            - If \"log2\", then `max_features=log2(n_features)`.\n            - If None, then `max_features=n_features`.\n\n        Note: the search for a split does not stop until at least one\n        valid partition of the node samples is found, even if it requires to\n        effectively inspect more than ``max_features`` features.\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    max_leaf_nodes : int or None, optional (default=None)\n        Grow a tree with ``max_leaf_nodes`` in best-first fashion.\n        Best nodes are defined as relative reduction in impurity.\n        If None then unlimited number of leaf nodes.\n\n    min_impurity_decrease : float, optional (default=0.)\n        A node will be split if this split induces a decrease of the impurity\n        greater than or equal to this value.\n\n        The weighted impurity decrease equation is the following::\n\n            N_t / N * (impurity - N_t_R / N_t * right_impurity\n                                - N_t_L / N_t * left_impurity)\n\n        where ``N`` is the total number of samples, ``N_t`` is the number of\n        samples at the current node, ``N_t_L`` is the number of samples in the\n        left child, and ``N_t_R`` is the number of samples in the right child.\n\n        ``N``, ``N_t``, ``N_t_R`` and ``N_t_L`` all refer to the weighted sum,\n        if ``sample_weight`` is passed.\n\n        .. versionadded:: 0.19\n\n    min_impurity_split : float,\n        Threshold for early stopping in tree growth. A node will split\n        if its impurity is above the threshold, otherwise it is a leaf.\n\n        .. deprecated:: 0.19\n           ``min_impurity_split`` has been deprecated in favor of\n           ``min_impurity_decrease`` in 0.19 and will be removed in 0.21.\n           Use ``min_impurity_decrease`` instead.\n\n    class_weight : dict, list of dicts, \"balanced\" or None, default=None\n        Weights associated with classes in the form ``{class_label: weight}``.\n        If not given, all classes are supposed to have weight one. For\n        multi-output problems, a list of dicts can be provided in the same\n        order as the columns of y.\n\n        Note that for multioutput (including multilabel) weights should be\n        defined for each class of every column in its own dict. For example,\n        for four-class multilabel classification weights should be\n        [{0: 1, 1: 1}, {0: 1, 1: 5}, {0: 1, 1: 1}, {0: 1, 1: 1}] instead of\n        [{1:1}, {2:5}, {3:1}, {4:1}].\n\n        The \"balanced\" mode uses the values of y to automatically adjust\n        weights inversely proportional to class frequencies in the input data\n        as ``n_samples / (n_classes * np.bincount(y))``\n\n        For multi-output, the weights of each column of y will be multiplied.\n\n        Note that these weights will be multiplied with sample_weight (passed\n        through the fit method) if sample_weight is specified.\n\n    presort : bool, optional (default=False)\n        Whether to presort the data to speed up the finding of best splits in\n        fitting. For the default settings of a decision tree on large\n        datasets, setting this to true may slow down the training process.\n        When using either a smaller dataset or a restricted depth, this may\n        speed up the training.\n\n    Attributes\n    ----------\n    classes_ : array of shape = [n_classes] or a list of such arrays\n        The classes labels (single output problem),\n        or a list of arrays of class labels (multi-output problem).\n\n    feature_importances_ : array of shape = [n_features]\n        The feature importances. The higher, the more important the\n        feature. The importance of a feature is computed as the (normalized)\n        total reduction of the criterion brought by that feature.  It is also\n        known as the Gini importance [4]_.\n\n    max_features_ : int,\n        The inferred value of max_features.\n\n    n_classes_ : int or list\n        The number of classes (for single output problems),\n        or a list containing the number of classes for each\n        output (for multi-output problems).\n\n    n_features_ : int\n        The number of features when ``fit`` is performed.\n\n    n_outputs_ : int\n        The number of outputs when ``fit`` is performed.\n\n    tree_ : Tree object\n        The underlying Tree object. Please refer to\n        ``help(sklearn.tree._tree.Tree)`` for attributes of Tree object and\n        :ref:`sphx_glr_auto_examples_tree_plot_unveil_tree_structure.py`\n        for basic usage of these attributes.\n\n    Notes\n    -----\n    The default values for the parameters controlling the size of the trees\n    (e.g. ``max_depth``, ``min_samples_leaf``, etc.) lead to fully grown and\n    unpruned trees which can potentially be very large on some data sets. To\n    reduce memory consumption, the complexity and size of the trees should be\n    controlled by setting those parameter values.\n\n    The features are always randomly permuted at each split. Therefore,\n    the best found split may vary, even with the same training data and\n    ``max_features=n_features``, if the improvement of the criterion is\n    identical for several splits enumerated during the search of the best\n    split. To obtain a deterministic behaviour during fitting,\n    ``random_state`` has to be fixed.\n\n    See also\n    --------\n    DecisionTreeRegressor\n\n    References\n    ----------\n\n    .. [1] https://en.wikipedia.org/wiki/Decision_tree_learning\n\n    .. [2] L. Breiman, J. Friedman, R. Olshen, and C. Stone, \"Classification\n           and Regression Trees\", Wadsworth, Belmont, CA, 1984.\n\n    .. [3] T. Hastie, R. Tibshirani and J. Friedman. \"Elements of Statistical\n           Learning\", Springer, 2009.\n\n    .. [4] L. Breiman, and A. Cutler, \"Random Forests\",\n           http://www.stat.berkeley.edu/~breiman/RandomForests/cc_home.htm\n\n    Examples\n    --------\n    >>> from sklearn.datasets import load_iris\n    >>> from sklearn.model_selection import cross_val_score\n    >>> from sklearn.tree import DecisionTreeClassifier\n    >>> clf = DecisionTreeClassifier(random_state=0)\n    >>> iris = load_iris()\n    >>> cross_val_score(clf, iris.data, iris.target, cv=10)\n    ...                             # doctest: +SKIP\n    ...\n    array([ 1.     ,  0.93...,  0.86...,  0.93...,  0.93...,\n            0.93...,  0.93...,  1.     ,  0.93...,  1.      ])\n    "
        },
        {
            "classifier": "sklearn.ensemble.forest.ExtraTreeClassifier",
            "name": "Extra Tree Classifier",
            "default_values": [
                {
                    "key": "criterion",
                    "value": "gini",
                    "type_": "str"
                },
                {
                    "key": "max_features",
                    "value": "auto",
                    "type_": "str"
                },
                {
                    "key": "min_impurity_decrease",
                    "value": 0.0,
                    "type_": "float"
                },
                {
                    "key": "min_samples_leaf",
                    "value": 1,
                    "type_": "int"
                },
                {
                    "key": "min_samples_split",
                    "value": 2,
                    "type_": "int"
                },
                {
                    "key": "min_weight_fraction_leaf",
                    "value": 0.0,
                    "type_": "float"
                },
                {
                    "key": "splitter",
                    "value": "random",
                    "type_": "str"
                }
            ],
            "doc_string": "An extremely randomized tree classifier.\n\n    Extra-trees differ from classic decision trees in the way they are built.\n    When looking for the best split to separate the samples of a node into two\n    groups, random splits are drawn for each of the `max_features` randomly\n    selected features and the best split among those is chosen. When\n    `max_features` is set 1, this amounts to building a totally random\n    decision tree.\n\n    Warning: Extra-trees should only be used within ensemble methods.\n\n    Read more in the :ref:`User Guide <tree>`.\n\n    Parameters\n    ----------\n    criterion : string, optional (default=\"gini\")\n        The function to measure the quality of a split. Supported criteria are\n        \"gini\" for the Gini impurity and \"entropy\" for the information gain.\n\n    splitter : string, optional (default=\"random\")\n        The strategy used to choose the split at each node. Supported\n        strategies are \"best\" to choose the best split and \"random\" to choose\n        the best random split.\n\n    max_depth : int or None, optional (default=None)\n        The maximum depth of the tree. If None, then nodes are expanded until\n        all leaves are pure or until all leaves contain less than\n        min_samples_split samples.\n\n    min_samples_split : int, float, optional (default=2)\n        The minimum number of samples required to split an internal node:\n\n        - If int, then consider `min_samples_split` as the minimum number.\n        - If float, then `min_samples_split` is a fraction and\n          `ceil(min_samples_split * n_samples)` are the minimum\n          number of samples for each split.\n\n        .. versionchanged:: 0.18\n           Added float values for fractions.\n\n    min_samples_leaf : int, float, optional (default=1)\n        The minimum number of samples required to be at a leaf node.\n        A split point at any depth will only be considered if it leaves at\n        least ``min_samples_leaf`` training samples in each of the left and\n        right branches.  This may have the effect of smoothing the model,\n        especially in regression.\n\n        - If int, then consider `min_samples_leaf` as the minimum number.\n        - If float, then `min_samples_leaf` is a fraction and\n          `ceil(min_samples_leaf * n_samples)` are the minimum\n          number of samples for each node.\n\n        .. versionchanged:: 0.18\n           Added float values for fractions.\n\n    min_weight_fraction_leaf : float, optional (default=0.)\n        The minimum weighted fraction of the sum total of weights (of all\n        the input samples) required to be at a leaf node. Samples have\n        equal weight when sample_weight is not provided.\n\n    max_features : int, float, string or None, optional (default=\"auto\")\n        The number of features to consider when looking for the best split:\n\n            - If int, then consider `max_features` features at each split.\n            - If float, then `max_features` is a fraction and\n              `int(max_features * n_features)` features are considered at each\n              split.\n            - If \"auto\", then `max_features=sqrt(n_features)`.\n            - If \"sqrt\", then `max_features=sqrt(n_features)`.\n            - If \"log2\", then `max_features=log2(n_features)`.\n            - If None, then `max_features=n_features`.\n\n        Note: the search for a split does not stop until at least one\n        valid partition of the node samples is found, even if it requires to\n        effectively inspect more than ``max_features`` features.\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    max_leaf_nodes : int or None, optional (default=None)\n        Grow a tree with ``max_leaf_nodes`` in best-first fashion.\n        Best nodes are defined as relative reduction in impurity.\n        If None then unlimited number of leaf nodes.\n\n    min_impurity_decrease : float, optional (default=0.)\n        A node will be split if this split induces a decrease of the impurity\n        greater than or equal to this value.\n\n        The weighted impurity decrease equation is the following::\n\n            N_t / N * (impurity - N_t_R / N_t * right_impurity\n                                - N_t_L / N_t * left_impurity)\n\n        where ``N`` is the total number of samples, ``N_t`` is the number of\n        samples at the current node, ``N_t_L`` is the number of samples in the\n        left child, and ``N_t_R`` is the number of samples in the right child.\n\n        ``N``, ``N_t``, ``N_t_R`` and ``N_t_L`` all refer to the weighted sum,\n        if ``sample_weight`` is passed.\n\n        .. versionadded:: 0.19\n\n    min_impurity_split : float,\n        Threshold for early stopping in tree growth. A node will split\n        if its impurity is above the threshold, otherwise it is a leaf.\n\n        .. deprecated:: 0.19\n           ``min_impurity_split`` has been deprecated in favor of\n           ``min_impurity_decrease`` in 0.19 and will be removed in 0.21.\n           Use ``min_impurity_decrease`` instead.\n\n    class_weight : dict, list of dicts, \"balanced\" or None, default=None\n        Weights associated with classes in the form ``{class_label: weight}``.\n        If not given, all classes are supposed to have weight one. For\n        multi-output problems, a list of dicts can be provided in the same\n        order as the columns of y.\n\n        Note that for multioutput (including multilabel) weights should be\n        defined for each class of every column in its own dict. For example,\n        for four-class multilabel classification weights should be\n        [{0: 1, 1: 1}, {0: 1, 1: 5}, {0: 1, 1: 1}, {0: 1, 1: 1}] instead of\n        [{1:1}, {2:5}, {3:1}, {4:1}].\n\n        The \"balanced\" mode uses the values of y to automatically adjust\n        weights inversely proportional to class frequencies in the input data\n        as ``n_samples / (n_classes * np.bincount(y))``\n\n        For multi-output, the weights of each column of y will be multiplied.\n\n        Note that these weights will be multiplied with sample_weight (passed\n        through the fit method) if sample_weight is specified.\n\n    See also\n    --------\n    ExtraTreeRegressor, sklearn.ensemble.ExtraTreesClassifier,\n    sklearn.ensemble.ExtraTreesRegressor\n\n    Notes\n    -----\n    The default values for the parameters controlling the size of the trees\n    (e.g. ``max_depth``, ``min_samples_leaf``, etc.) lead to fully grown and\n    unpruned trees which can potentially be very large on some data sets. To\n    reduce memory consumption, the complexity and size of the trees should be\n    controlled by setting those parameter values.\n\n    References\n    ----------\n\n    .. [1] P. Geurts, D. Ernst., and L. Wehenkel, \"Extremely randomized trees\",\n           Machine Learning, 63(1), 3-42, 2006.\n    "
        },
        {
            "classifier": "sklearn.ensemble.forest.ExtraTreesClassifier",
            "name": "Extra Trees Classifier",
            "default_values": [
                {
                    "key": "bootstrap",
                    "value": false,
                    "type_": "bool"
                },
                {
                    "key": "criterion",
                    "value": "gini",
                    "type_": "str"
                },
                {
                    "key": "max_features",
                    "value": "auto",
                    "type_": "str"
                },
                {
                    "key": "min_impurity_decrease",
                    "value": 0.0,
                    "type_": "float"
                },
                {
                    "key": "min_samples_leaf",
                    "value": 1,
                    "type_": "int"
                },
                {
                    "key": "min_samples_split",
                    "value": 2,
                    "type_": "int"
                },
                {
                    "key": "min_weight_fraction_leaf",
                    "value": 0.0,
                    "type_": "float"
                },
                {
                    "key": "n_estimators",
                    "value": "warn",
                    "type_": "str"
                },
                {
                    "key": "oob_score",
                    "value": false,
                    "type_": "bool"
                },
                {
                    "key": "verbose",
                    "value": 0,
                    "type_": "int"
                },
                {
                    "key": "warm_start",
                    "value": false,
                    "type_": "bool"
                }
            ],
            "doc_string": "An extra-trees classifier.\n\n    This class implements a meta estimator that fits a number of\n    randomized decision trees (a.k.a. extra-trees) on various sub-samples\n    of the dataset and uses averaging to improve the predictive accuracy\n    and control over-fitting.\n\n    Read more in the :ref:`User Guide <forest>`.\n\n    Parameters\n    ----------\n    n_estimators : integer, optional (default=10)\n        The number of trees in the forest.\n\n        .. versionchanged:: 0.20\n           The default value of ``n_estimators`` will change from 10 in\n           version 0.20 to 100 in version 0.22.\n\n    criterion : string, optional (default=\"gini\")\n        The function to measure the quality of a split. Supported criteria are\n        \"gini\" for the Gini impurity and \"entropy\" for the information gain.\n\n    max_depth : integer or None, optional (default=None)\n        The maximum depth of the tree. If None, then nodes are expanded until\n        all leaves are pure or until all leaves contain less than\n        min_samples_split samples.\n\n    min_samples_split : int, float, optional (default=2)\n        The minimum number of samples required to split an internal node:\n\n        - If int, then consider `min_samples_split` as the minimum number.\n        - If float, then `min_samples_split` is a fraction and\n          `ceil(min_samples_split * n_samples)` are the minimum\n          number of samples for each split.\n\n        .. versionchanged:: 0.18\n           Added float values for fractions.\n\n    min_samples_leaf : int, float, optional (default=1)\n        The minimum number of samples required to be at a leaf node.\n        A split point at any depth will only be considered if it leaves at\n        least ``min_samples_leaf`` training samples in each of the left and\n        right branches.  This may have the effect of smoothing the model,\n        especially in regression.\n\n        - If int, then consider `min_samples_leaf` as the minimum number.\n        - If float, then `min_samples_leaf` is a fraction and\n          `ceil(min_samples_leaf * n_samples)` are the minimum\n          number of samples for each node.\n\n        .. versionchanged:: 0.18\n           Added float values for fractions.\n\n    min_weight_fraction_leaf : float, optional (default=0.)\n        The minimum weighted fraction of the sum total of weights (of all\n        the input samples) required to be at a leaf node. Samples have\n        equal weight when sample_weight is not provided.\n\n    max_features : int, float, string or None, optional (default=\"auto\")\n        The number of features to consider when looking for the best split:\n\n        - If int, then consider `max_features` features at each split.\n        - If float, then `max_features` is a fraction and\n          `int(max_features * n_features)` features are considered at each\n          split.\n        - If \"auto\", then `max_features=sqrt(n_features)`.\n        - If \"sqrt\", then `max_features=sqrt(n_features)`.\n        - If \"log2\", then `max_features=log2(n_features)`.\n        - If None, then `max_features=n_features`.\n\n        Note: the search for a split does not stop until at least one\n        valid partition of the node samples is found, even if it requires to\n        effectively inspect more than ``max_features`` features.\n\n    max_leaf_nodes : int or None, optional (default=None)\n        Grow trees with ``max_leaf_nodes`` in best-first fashion.\n        Best nodes are defined as relative reduction in impurity.\n        If None then unlimited number of leaf nodes.\n\n    min_impurity_decrease : float, optional (default=0.)\n        A node will be split if this split induces a decrease of the impurity\n        greater than or equal to this value.\n\n        The weighted impurity decrease equation is the following::\n\n            N_t / N * (impurity - N_t_R / N_t * right_impurity\n                                - N_t_L / N_t * left_impurity)\n\n        where ``N`` is the total number of samples, ``N_t`` is the number of\n        samples at the current node, ``N_t_L`` is the number of samples in the\n        left child, and ``N_t_R`` is the number of samples in the right child.\n\n        ``N``, ``N_t``, ``N_t_R`` and ``N_t_L`` all refer to the weighted sum,\n        if ``sample_weight`` is passed.\n\n        .. versionadded:: 0.19\n\n    min_impurity_split : float,\n        Threshold for early stopping in tree growth. A node will split\n        if its impurity is above the threshold, otherwise it is a leaf.\n\n        .. deprecated:: 0.19\n           ``min_impurity_split`` has been deprecated in favor of\n           ``min_impurity_decrease`` in 0.19 and will be removed in 0.21.\n           Use ``min_impurity_decrease`` instead.\n\n    bootstrap : boolean, optional (default=False)\n        Whether bootstrap samples are used when building trees.\n\n    oob_score : bool, optional (default=False)\n        Whether to use out-of-bag samples to estimate\n        the generalization accuracy.\n\n    n_jobs : int or None, optional (default=None)\n        The number of jobs to run in parallel for both `fit` and `predict`.\n        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n        ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n        for more details.\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    verbose : int, optional (default=0)\n        Controls the verbosity when fitting and predicting.\n\n    warm_start : bool, optional (default=False)\n        When set to ``True``, reuse the solution of the previous call to fit\n        and add more estimators to the ensemble, otherwise, just fit a whole\n        new forest. See :term:`the Glossary <warm_start>`.\n\n    class_weight : dict, list of dicts, \"balanced\", \"balanced_subsample\" or     None, optional (default=None)\n        Weights associated with classes in the form ``{class_label: weight}``.\n        If not given, all classes are supposed to have weight one. For\n        multi-output problems, a list of dicts can be provided in the same\n        order as the columns of y.\n\n        Note that for multioutput (including multilabel) weights should be\n        defined for each class of every column in its own dict. For example,\n        for four-class multilabel classification weights should be\n        [{0: 1, 1: 1}, {0: 1, 1: 5}, {0: 1, 1: 1}, {0: 1, 1: 1}] instead of\n        [{1:1}, {2:5}, {3:1}, {4:1}].\n\n        The \"balanced\" mode uses the values of y to automatically adjust\n        weights inversely proportional to class frequencies in the input data\n        as ``n_samples / (n_classes * np.bincount(y))``\n\n        The \"balanced_subsample\" mode is the same as \"balanced\" except that weights are\n        computed based on the bootstrap sample for every tree grown.\n\n        For multi-output, the weights of each column of y will be multiplied.\n\n        Note that these weights will be multiplied with sample_weight (passed\n        through the fit method) if sample_weight is specified.\n\n    Attributes\n    ----------\n    estimators_ : list of DecisionTreeClassifier\n        The collection of fitted sub-estimators.\n\n    classes_ : array of shape = [n_classes] or a list of such arrays\n        The classes labels (single output problem), or a list of arrays of\n        class labels (multi-output problem).\n\n    n_classes_ : int or list\n        The number of classes (single output problem), or a list containing the\n        number of classes for each output (multi-output problem).\n\n    feature_importances_ : array of shape = [n_features]\n        The feature importances (the higher, the more important the feature).\n\n    n_features_ : int\n        The number of features when ``fit`` is performed.\n\n    n_outputs_ : int\n        The number of outputs when ``fit`` is performed.\n\n    oob_score_ : float\n        Score of the training dataset obtained using an out-of-bag estimate.\n\n    oob_decision_function_ : array of shape = [n_samples, n_classes]\n        Decision function computed with out-of-bag estimate on the training\n        set. If n_estimators is small it might be possible that a data point\n        was never left out during the bootstrap. In this case,\n        `oob_decision_function_` might contain NaN.\n\n    Notes\n    -----\n    The default values for the parameters controlling the size of the trees\n    (e.g. ``max_depth``, ``min_samples_leaf``, etc.) lead to fully grown and\n    unpruned trees which can potentially be very large on some data sets. To\n    reduce memory consumption, the complexity and size of the trees should be\n    controlled by setting those parameter values.\n\n    References\n    ----------\n\n    .. [1] P. Geurts, D. Ernst., and L. Wehenkel, \"Extremely randomized \n           trees\", Machine Learning, 63(1), 3-42, 2006.\n\n    See also\n    --------\n    sklearn.tree.ExtraTreeClassifier : Base classifier for this ensemble.\n    RandomForestClassifier : Ensemble Classifier based on trees with optimal\n        splits.\n    "
        },
        {
            "classifier": "sklearn.ensemble.forest.RandomForestClassifier",
            "name": "Random Forest Classifier",
            "default_values": [
                {
                    "key": "bootstrap",
                    "value": true,
                    "type_": "bool"
                },
                {
                    "key": "criterion",
                    "value": "gini",
                    "type_": "str"
                },
                {
                    "key": "max_features",
                    "value": "auto",
                    "type_": "str"
                },
                {
                    "key": "min_impurity_decrease",
                    "value": 0.0,
                    "type_": "float"
                },
                {
                    "key": "min_samples_leaf",
                    "value": 1,
                    "type_": "int"
                },
                {
                    "key": "min_samples_split",
                    "value": 2,
                    "type_": "int"
                },
                {
                    "key": "min_weight_fraction_leaf",
                    "value": 0.0,
                    "type_": "float"
                },
                {
                    "key": "n_estimators",
                    "value": "warn",
                    "type_": "str"
                },
                {
                    "key": "oob_score",
                    "value": false,
                    "type_": "bool"
                },
                {
                    "key": "verbose",
                    "value": 0,
                    "type_": "int"
                },
                {
                    "key": "warm_start",
                    "value": false,
                    "type_": "bool"
                }
            ],
            "doc_string": "A random forest classifier.\n\n    A random forest is a meta estimator that fits a number of decision tree\n    classifiers on various sub-samples of the dataset and uses averaging to\n    improve the predictive accuracy and control over-fitting.\n    The sub-sample size is always the same as the original\n    input sample size but the samples are drawn with replacement if\n    `bootstrap=True` (default).\n\n    Read more in the :ref:`User Guide <forest>`.\n\n    Parameters\n    ----------\n    n_estimators : integer, optional (default=10)\n        The number of trees in the forest.\n\n        .. versionchanged:: 0.20\n           The default value of ``n_estimators`` will change from 10 in\n           version 0.20 to 100 in version 0.22.\n\n    criterion : string, optional (default=\"gini\")\n        The function to measure the quality of a split. Supported criteria are\n        \"gini\" for the Gini impurity and \"entropy\" for the information gain.\n        Note: this parameter is tree-specific.\n\n    max_depth : integer or None, optional (default=None)\n        The maximum depth of the tree. If None, then nodes are expanded until\n        all leaves are pure or until all leaves contain less than\n        min_samples_split samples.\n\n    min_samples_split : int, float, optional (default=2)\n        The minimum number of samples required to split an internal node:\n\n        - If int, then consider `min_samples_split` as the minimum number.\n        - If float, then `min_samples_split` is a fraction and\n          `ceil(min_samples_split * n_samples)` are the minimum\n          number of samples for each split.\n\n        .. versionchanged:: 0.18\n           Added float values for fractions.\n\n    min_samples_leaf : int, float, optional (default=1)\n        The minimum number of samples required to be at a leaf node.\n        A split point at any depth will only be considered if it leaves at\n        least ``min_samples_leaf`` training samples in each of the left and\n        right branches.  This may have the effect of smoothing the model,\n        especially in regression.\n\n        - If int, then consider `min_samples_leaf` as the minimum number.\n        - If float, then `min_samples_leaf` is a fraction and\n          `ceil(min_samples_leaf * n_samples)` are the minimum\n          number of samples for each node.\n\n        .. versionchanged:: 0.18\n           Added float values for fractions.\n\n    min_weight_fraction_leaf : float, optional (default=0.)\n        The minimum weighted fraction of the sum total of weights (of all\n        the input samples) required to be at a leaf node. Samples have\n        equal weight when sample_weight is not provided.\n\n    max_features : int, float, string or None, optional (default=\"auto\")\n        The number of features to consider when looking for the best split:\n\n        - If int, then consider `max_features` features at each split.\n        - If float, then `max_features` is a fraction and\n          `int(max_features * n_features)` features are considered at each\n          split.\n        - If \"auto\", then `max_features=sqrt(n_features)`.\n        - If \"sqrt\", then `max_features=sqrt(n_features)` (same as \"auto\").\n        - If \"log2\", then `max_features=log2(n_features)`.\n        - If None, then `max_features=n_features`.\n\n        Note: the search for a split does not stop until at least one\n        valid partition of the node samples is found, even if it requires to\n        effectively inspect more than ``max_features`` features.\n\n    max_leaf_nodes : int or None, optional (default=None)\n        Grow trees with ``max_leaf_nodes`` in best-first fashion.\n        Best nodes are defined as relative reduction in impurity.\n        If None then unlimited number of leaf nodes.\n\n    min_impurity_decrease : float, optional (default=0.)\n        A node will be split if this split induces a decrease of the impurity\n        greater than or equal to this value.\n\n        The weighted impurity decrease equation is the following::\n\n            N_t / N * (impurity - N_t_R / N_t * right_impurity\n                                - N_t_L / N_t * left_impurity)\n\n        where ``N`` is the total number of samples, ``N_t`` is the number of\n        samples at the current node, ``N_t_L`` is the number of samples in the\n        left child, and ``N_t_R`` is the number of samples in the right child.\n\n        ``N``, ``N_t``, ``N_t_R`` and ``N_t_L`` all refer to the weighted sum,\n        if ``sample_weight`` is passed.\n\n        .. versionadded:: 0.19\n\n    min_impurity_split : float,\n        Threshold for early stopping in tree growth. A node will split\n        if its impurity is above the threshold, otherwise it is a leaf.\n\n        .. deprecated:: 0.19\n           ``min_impurity_split`` has been deprecated in favor of\n           ``min_impurity_decrease`` in 0.19 and will be removed in 0.21.\n           Use ``min_impurity_decrease`` instead.\n\n    bootstrap : boolean, optional (default=True)\n        Whether bootstrap samples are used when building trees.\n\n    oob_score : bool (default=False)\n        Whether to use out-of-bag samples to estimate\n        the generalization accuracy.\n\n    n_jobs : int or None, optional (default=None)\n        The number of jobs to run in parallel for both `fit` and `predict`.\n        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n        ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n        for more details.\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    verbose : int, optional (default=0)\n        Controls the verbosity when fitting and predicting.\n\n    warm_start : bool, optional (default=False)\n        When set to ``True``, reuse the solution of the previous call to fit\n        and add more estimators to the ensemble, otherwise, just fit a whole\n        new forest. See :term:`the Glossary <warm_start>`.\n\n    class_weight : dict, list of dicts, \"balanced\", \"balanced_subsample\" or     None, optional (default=None)\n        Weights associated with classes in the form ``{class_label: weight}``.\n        If not given, all classes are supposed to have weight one. For\n        multi-output problems, a list of dicts can be provided in the same\n        order as the columns of y.\n\n        Note that for multioutput (including multilabel) weights should be\n        defined for each class of every column in its own dict. For example,\n        for four-class multilabel classification weights should be\n        [{0: 1, 1: 1}, {0: 1, 1: 5}, {0: 1, 1: 1}, {0: 1, 1: 1}] instead of\n        [{1:1}, {2:5}, {3:1}, {4:1}].\n\n        The \"balanced\" mode uses the values of y to automatically adjust\n        weights inversely proportional to class frequencies in the input data\n        as ``n_samples / (n_classes * np.bincount(y))``\n\n        The \"balanced_subsample\" mode is the same as \"balanced\" except that\n        weights are computed based on the bootstrap sample for every tree\n        grown.\n\n        For multi-output, the weights of each column of y will be multiplied.\n\n        Note that these weights will be multiplied with sample_weight (passed\n        through the fit method) if sample_weight is specified.\n\n    Attributes\n    ----------\n    estimators_ : list of DecisionTreeClassifier\n        The collection of fitted sub-estimators.\n\n    classes_ : array of shape = [n_classes] or a list of such arrays\n        The classes labels (single output problem), or a list of arrays of\n        class labels (multi-output problem).\n\n    n_classes_ : int or list\n        The number of classes (single output problem), or a list containing the\n        number of classes for each output (multi-output problem).\n\n    n_features_ : int\n        The number of features when ``fit`` is performed.\n\n    n_outputs_ : int\n        The number of outputs when ``fit`` is performed.\n\n    feature_importances_ : array of shape = [n_features]\n        The feature importances (the higher, the more important the feature).\n\n    oob_score_ : float\n        Score of the training dataset obtained using an out-of-bag estimate.\n\n    oob_decision_function_ : array of shape = [n_samples, n_classes]\n        Decision function computed with out-of-bag estimate on the training\n        set. If n_estimators is small it might be possible that a data point\n        was never left out during the bootstrap. In this case,\n        `oob_decision_function_` might contain NaN.\n\n    Examples\n    --------\n    >>> from sklearn.ensemble import RandomForestClassifier\n    >>> from sklearn.datasets import make_classification\n    >>>\n    >>> X, y = make_classification(n_samples=1000, n_features=4,\n    ...                            n_informative=2, n_redundant=0,\n    ...                            random_state=0, shuffle=False)\n    >>> clf = RandomForestClassifier(n_estimators=100, max_depth=2,\n    ...                              random_state=0)\n    >>> clf.fit(X, y)\n    RandomForestClassifier(bootstrap=True, class_weight=None, criterion='gini',\n                max_depth=2, max_features='auto', max_leaf_nodes=None,\n                min_impurity_decrease=0.0, min_impurity_split=None,\n                min_samples_leaf=1, min_samples_split=2,\n                min_weight_fraction_leaf=0.0, n_estimators=100, n_jobs=None,\n                oob_score=False, random_state=0, verbose=0, warm_start=False)\n    >>> print(clf.feature_importances_)\n    [0.14205973 0.76664038 0.0282433  0.06305659]\n    >>> print(clf.predict([[0, 0, 0, 0]]))\n    [1]\n\n    Notes\n    -----\n    The default values for the parameters controlling the size of the trees\n    (e.g. ``max_depth``, ``min_samples_leaf``, etc.) lead to fully grown and\n    unpruned trees which can potentially be very large on some data sets. To\n    reduce memory consumption, the complexity and size of the trees should be\n    controlled by setting those parameter values.\n\n    The features are always randomly permuted at each split. Therefore,\n    the best found split may vary, even with the same training data,\n    ``max_features=n_features`` and ``bootstrap=False``, if the improvement\n    of the criterion is identical for several splits enumerated during the\n    search of the best split. To obtain a deterministic behaviour during\n    fitting, ``random_state`` has to be fixed.\n\n    References\n    ----------\n\n    .. [1] L. Breiman, \"Random Forests\", Machine Learning, 45(1), 5-32, 2001.\n\n    See also\n    --------\n    DecisionTreeClassifier, ExtraTreesClassifier\n    "
        },
        {
            "classifier": "sklearn.ensemble.gradient_boosting.GradientBoostingClassifier",
            "name": "Gradient Boosting Classifier",
            "default_values": [
                {
                    "key": "criterion",
                    "value": "friedman_mse",
                    "type_": "str"
                },
                {
                    "key": "learning_rate",
                    "value": 0.1,
                    "type_": "float"
                },
                {
                    "key": "loss",
                    "value": "deviance",
                    "type_": "str"
                },
                {
                    "key": "max_depth",
                    "value": 3,
                    "type_": "int"
                },
                {
                    "key": "min_impurity_decrease",
                    "value": 0.0,
                    "type_": "float"
                },
                {
                    "key": "min_samples_leaf",
                    "value": 1,
                    "type_": "int"
                },
                {
                    "key": "min_samples_split",
                    "value": 2,
                    "type_": "int"
                },
                {
                    "key": "min_weight_fraction_leaf",
                    "value": 0.0,
                    "type_": "float"
                },
                {
                    "key": "n_estimators",
                    "value": 100,
                    "type_": "int"
                },
                {
                    "key": "presort",
                    "value": "auto",
                    "type_": "str"
                },
                {
                    "key": "subsample",
                    "value": 1.0,
                    "type_": "float"
                },
                {
                    "key": "tol",
                    "value": 0.0001,
                    "type_": "float"
                },
                {
                    "key": "validation_fraction",
                    "value": 0.1,
                    "type_": "float"
                },
                {
                    "key": "verbose",
                    "value": 0,
                    "type_": "int"
                },
                {
                    "key": "warm_start",
                    "value": false,
                    "type_": "bool"
                }
            ],
            "doc_string": "Gradient Boosting for classification.\n\n    GB builds an additive model in a\n    forward stage-wise fashion; it allows for the optimization of\n    arbitrary differentiable loss functions. In each stage ``n_classes_``\n    regression trees are fit on the negative gradient of the\n    binomial or multinomial deviance loss function. Binary classification\n    is a special case where only a single regression tree is induced.\n\n    Read more in the :ref:`User Guide <gradient_boosting>`.\n\n    Parameters\n    ----------\n    loss : {'deviance', 'exponential'}, optional (default='deviance')\n        loss function to be optimized. 'deviance' refers to\n        deviance (= logistic regression) for classification\n        with probabilistic outputs. For loss 'exponential' gradient\n        boosting recovers the AdaBoost algorithm.\n\n    learning_rate : float, optional (default=0.1)\n        learning rate shrinks the contribution of each tree by `learning_rate`.\n        There is a trade-off between learning_rate and n_estimators.\n\n    n_estimators : int (default=100)\n        The number of boosting stages to perform. Gradient boosting\n        is fairly robust to over-fitting so a large number usually\n        results in better performance.\n\n    subsample : float, optional (default=1.0)\n        The fraction of samples to be used for fitting the individual base\n        learners. If smaller than 1.0 this results in Stochastic Gradient\n        Boosting. `subsample` interacts with the parameter `n_estimators`.\n        Choosing `subsample < 1.0` leads to a reduction of variance\n        and an increase in bias.\n\n    criterion : string, optional (default=\"friedman_mse\")\n        The function to measure the quality of a split. Supported criteria\n        are \"friedman_mse\" for the mean squared error with improvement\n        score by Friedman, \"mse\" for mean squared error, and \"mae\" for\n        the mean absolute error. The default value of \"friedman_mse\" is\n        generally the best as it can provide a better approximation in\n        some cases.\n\n        .. versionadded:: 0.18\n\n    min_samples_split : int, float, optional (default=2)\n        The minimum number of samples required to split an internal node:\n\n        - If int, then consider `min_samples_split` as the minimum number.\n        - If float, then `min_samples_split` is a fraction and\n          `ceil(min_samples_split * n_samples)` are the minimum\n          number of samples for each split.\n\n        .. versionchanged:: 0.18\n           Added float values for fractions.\n\n    min_samples_leaf : int, float, optional (default=1)\n        The minimum number of samples required to be at a leaf node.\n        A split point at any depth will only be considered if it leaves at\n        least ``min_samples_leaf`` training samples in each of the left and\n        right branches.  This may have the effect of smoothing the model,\n        especially in regression.\n\n        - If int, then consider `min_samples_leaf` as the minimum number.\n        - If float, then `min_samples_leaf` is a fraction and\n          `ceil(min_samples_leaf * n_samples)` are the minimum\n          number of samples for each node.\n\n        .. versionchanged:: 0.18\n           Added float values for fractions.\n\n    min_weight_fraction_leaf : float, optional (default=0.)\n        The minimum weighted fraction of the sum total of weights (of all\n        the input samples) required to be at a leaf node. Samples have\n        equal weight when sample_weight is not provided.\n\n    max_depth : integer, optional (default=3)\n        maximum depth of the individual regression estimators. The maximum\n        depth limits the number of nodes in the tree. Tune this parameter\n        for best performance; the best value depends on the interaction\n        of the input variables.\n\n    min_impurity_decrease : float, optional (default=0.)\n        A node will be split if this split induces a decrease of the impurity\n        greater than or equal to this value.\n\n        The weighted impurity decrease equation is the following::\n\n            N_t / N * (impurity - N_t_R / N_t * right_impurity\n                                - N_t_L / N_t * left_impurity)\n\n        where ``N`` is the total number of samples, ``N_t`` is the number of\n        samples at the current node, ``N_t_L`` is the number of samples in the\n        left child, and ``N_t_R`` is the number of samples in the right child.\n\n        ``N``, ``N_t``, ``N_t_R`` and ``N_t_L`` all refer to the weighted sum,\n        if ``sample_weight`` is passed.\n\n        .. versionadded:: 0.19\n\n    min_impurity_split : float,\n        Threshold for early stopping in tree growth. A node will split\n        if its impurity is above the threshold, otherwise it is a leaf.\n\n        .. deprecated:: 0.19\n           ``min_impurity_split`` has been deprecated in favor of\n           ``min_impurity_decrease`` in 0.19 and will be removed in 0.21.\n           Use ``min_impurity_decrease`` instead.\n\n    init : estimator, optional\n        An estimator object that is used to compute the initial\n        predictions. ``init`` has to provide ``fit`` and ``predict``.\n        If None it uses ``loss.init_estimator``.\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    max_features : int, float, string or None, optional (default=None)\n        The number of features to consider when looking for the best split:\n\n        - If int, then consider `max_features` features at each split.\n        - If float, then `max_features` is a fraction and\n          `int(max_features * n_features)` features are considered at each\n          split.\n        - If \"auto\", then `max_features=sqrt(n_features)`.\n        - If \"sqrt\", then `max_features=sqrt(n_features)`.\n        - If \"log2\", then `max_features=log2(n_features)`.\n        - If None, then `max_features=n_features`.\n\n        Choosing `max_features < n_features` leads to a reduction of variance\n        and an increase in bias.\n\n        Note: the search for a split does not stop until at least one\n        valid partition of the node samples is found, even if it requires to\n        effectively inspect more than ``max_features`` features.\n\n    verbose : int, default: 0\n        Enable verbose output. If 1 then it prints progress and performance\n        once in a while (the more trees the lower the frequency). If greater\n        than 1 then it prints progress and performance for every tree.\n\n    max_leaf_nodes : int or None, optional (default=None)\n        Grow trees with ``max_leaf_nodes`` in best-first fashion.\n        Best nodes are defined as relative reduction in impurity.\n        If None then unlimited number of leaf nodes.\n\n    warm_start : bool, default: False\n        When set to ``True``, reuse the solution of the previous call to fit\n        and add more estimators to the ensemble, otherwise, just erase the\n        previous solution. See :term:`the Glossary <warm_start>`.\n\n    presort : bool or 'auto', optional (default='auto')\n        Whether to presort the data to speed up the finding of best splits in\n        fitting. Auto mode by default will use presorting on dense data and\n        default to normal sorting on sparse data. Setting presort to true on\n        sparse data will raise an error.\n\n        .. versionadded:: 0.17\n           *presort* parameter.\n\n    validation_fraction : float, optional, default 0.1\n        The proportion of training data to set aside as validation set for\n        early stopping. Must be between 0 and 1.\n        Only used if ``n_iter_no_change`` is set to an integer.\n\n        .. versionadded:: 0.20\n\n    n_iter_no_change : int, default None\n        ``n_iter_no_change`` is used to decide if early stopping will be used\n        to terminate training when validation score is not improving. By\n        default it is set to None to disable early stopping. If set to a\n        number, it will set aside ``validation_fraction`` size of the training\n        data as validation and terminate training when validation score is not\n        improving in all of the previous ``n_iter_no_change`` numbers of\n        iterations.\n\n        .. versionadded:: 0.20\n\n    tol : float, optional, default 1e-4\n        Tolerance for the early stopping. When the loss is not improving\n        by at least tol for ``n_iter_no_change`` iterations (if set to a\n        number), the training stops.\n\n        .. versionadded:: 0.20\n\n    Attributes\n    ----------\n    n_estimators_ : int\n        The number of estimators as selected by early stopping (if\n        ``n_iter_no_change`` is specified). Otherwise it is set to\n        ``n_estimators``.\n\n        .. versionadded:: 0.20\n\n    feature_importances_ : array, shape (n_features,)\n        The feature importances (the higher, the more important the feature).\n\n    oob_improvement_ : array, shape (n_estimators,)\n        The improvement in loss (= deviance) on the out-of-bag samples\n        relative to the previous iteration.\n        ``oob_improvement_[0]`` is the improvement in\n        loss of the first stage over the ``init`` estimator.\n\n    train_score_ : array, shape (n_estimators,)\n        The i-th score ``train_score_[i]`` is the deviance (= loss) of the\n        model at iteration ``i`` on the in-bag sample.\n        If ``subsample == 1`` this is the deviance on the training data.\n\n    loss_ : LossFunction\n        The concrete ``LossFunction`` object.\n\n    init_ : estimator\n        The estimator that provides the initial predictions.\n        Set via the ``init`` argument or ``loss.init_estimator``.\n\n    estimators_ : ndarray of DecisionTreeRegressor,shape (n_estimators, ``loss_.K``)\n        The collection of fitted sub-estimators. ``loss_.K`` is 1 for binary\n        classification, otherwise n_classes.\n\n    Notes\n    -----\n    The features are always randomly permuted at each split. Therefore,\n    the best found split may vary, even with the same training data and\n    ``max_features=n_features``, if the improvement of the criterion is\n    identical for several splits enumerated during the search of the best\n    split. To obtain a deterministic behaviour during fitting,\n    ``random_state`` has to be fixed.\n\n    See also\n    --------\n    sklearn.tree.DecisionTreeClassifier, RandomForestClassifier\n    AdaBoostClassifier\n\n    References\n    ----------\n    J. Friedman, Greedy Function Approximation: A Gradient Boosting\n    Machine, The Annals of Statistics, Vol. 29, No. 5, 2001.\n\n    J. Friedman, Stochastic Gradient Boosting, 1999\n\n    T. Hastie, R. Tibshirani and J. Friedman.\n    Elements of Statistical Learning Ed. 2, Springer, 2009.\n    "
        },
        {
            "classifier": "sklearn.ensemble.weight_boosting.AdaBoostClassifier",
            "name": "Ada Boost Classifier",
            "default_values": [
                {
                    "key": "algorithm",
                    "value": "SAMME.R",
                    "type_": "str"
                },
                {
                    "key": "learning_rate",
                    "value": 1.0,
                    "type_": "float"
                },
                {
                    "key": "n_estimators",
                    "value": 50,
                    "type_": "int"
                }
            ],
            "doc_string": "An AdaBoost classifier.\n\n    An AdaBoost [1] classifier is a meta-estimator that begins by fitting a\n    classifier on the original dataset and then fits additional copies of the\n    classifier on the same dataset but where the weights of incorrectly\n    classified instances are adjusted such that subsequent classifiers focus\n    more on difficult cases.\n\n    This class implements the algorithm known as AdaBoost-SAMME [2].\n\n    Read more in the :ref:`User Guide <adaboost>`.\n\n    Parameters\n    ----------\n    base_estimator : object, optional (default=None)\n        The base estimator from which the boosted ensemble is built.\n        Support for sample weighting is required, as well as proper\n        ``classes_`` and ``n_classes_`` attributes. If ``None``, then\n        the base estimator is ``DecisionTreeClassifier(max_depth=1)``\n\n    n_estimators : integer, optional (default=50)\n        The maximum number of estimators at which boosting is terminated.\n        In case of perfect fit, the learning procedure is stopped early.\n\n    learning_rate : float, optional (default=1.)\n        Learning rate shrinks the contribution of each classifier by\n        ``learning_rate``. There is a trade-off between ``learning_rate`` and\n        ``n_estimators``.\n\n    algorithm : {'SAMME', 'SAMME.R'}, optional (default='SAMME.R')\n        If 'SAMME.R' then use the SAMME.R real boosting algorithm.\n        ``base_estimator`` must support calculation of class probabilities.\n        If 'SAMME' then use the SAMME discrete boosting algorithm.\n        The SAMME.R algorithm typically converges faster than SAMME,\n        achieving a lower test error with fewer boosting iterations.\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    Attributes\n    ----------\n    estimators_ : list of classifiers\n        The collection of fitted sub-estimators.\n\n    classes_ : array of shape = [n_classes]\n        The classes labels.\n\n    n_classes_ : int\n        The number of classes.\n\n    estimator_weights_ : array of floats\n        Weights for each estimator in the boosted ensemble.\n\n    estimator_errors_ : array of floats\n        Classification error for each estimator in the boosted\n        ensemble.\n\n    feature_importances_ : array of shape = [n_features]\n        The feature importances if supported by the ``base_estimator``.\n\n    See also\n    --------\n    AdaBoostRegressor, GradientBoostingClassifier,\n    sklearn.tree.DecisionTreeClassifier\n\n    References\n    ----------\n    .. [1] Y. Freund, R. Schapire, \"A Decision-Theoretic Generalization of\n           on-Line Learning and an Application to Boosting\", 1995.\n\n    .. [2] J. Zhu, H. Zou, S. Rosset, T. Hastie, \"Multi-class AdaBoost\", 2009.\n\n    "
        },
        {
            "classifier": "sklearn.ensemble.weight_boosting.DecisionTreeClassifier",
            "name": "Decision Tree Classifier",
            "default_values": [
                {
                    "key": "criterion",
                    "value": "gini",
                    "type_": "str"
                },
                {
                    "key": "min_impurity_decrease",
                    "value": 0.0,
                    "type_": "float"
                },
                {
                    "key": "min_samples_leaf",
                    "value": 1,
                    "type_": "int"
                },
                {
                    "key": "min_samples_split",
                    "value": 2,
                    "type_": "int"
                },
                {
                    "key": "min_weight_fraction_leaf",
                    "value": 0.0,
                    "type_": "float"
                },
                {
                    "key": "presort",
                    "value": false,
                    "type_": "bool"
                },
                {
                    "key": "splitter",
                    "value": "best",
                    "type_": "str"
                }
            ],
            "doc_string": "A decision tree classifier.\n\n    Read more in the :ref:`User Guide <tree>`.\n\n    Parameters\n    ----------\n    criterion : string, optional (default=\"gini\")\n        The function to measure the quality of a split. Supported criteria are\n        \"gini\" for the Gini impurity and \"entropy\" for the information gain.\n\n    splitter : string, optional (default=\"best\")\n        The strategy used to choose the split at each node. Supported\n        strategies are \"best\" to choose the best split and \"random\" to choose\n        the best random split.\n\n    max_depth : int or None, optional (default=None)\n        The maximum depth of the tree. If None, then nodes are expanded until\n        all leaves are pure or until all leaves contain less than\n        min_samples_split samples.\n\n    min_samples_split : int, float, optional (default=2)\n        The minimum number of samples required to split an internal node:\n\n        - If int, then consider `min_samples_split` as the minimum number.\n        - If float, then `min_samples_split` is a fraction and\n          `ceil(min_samples_split * n_samples)` are the minimum\n          number of samples for each split.\n\n        .. versionchanged:: 0.18\n           Added float values for fractions.\n\n    min_samples_leaf : int, float, optional (default=1)\n        The minimum number of samples required to be at a leaf node.\n        A split point at any depth will only be considered if it leaves at\n        least ``min_samples_leaf`` training samples in each of the left and\n        right branches.  This may have the effect of smoothing the model,\n        especially in regression.\n\n        - If int, then consider `min_samples_leaf` as the minimum number.\n        - If float, then `min_samples_leaf` is a fraction and\n          `ceil(min_samples_leaf * n_samples)` are the minimum\n          number of samples for each node.\n\n        .. versionchanged:: 0.18\n           Added float values for fractions.\n\n    min_weight_fraction_leaf : float, optional (default=0.)\n        The minimum weighted fraction of the sum total of weights (of all\n        the input samples) required to be at a leaf node. Samples have\n        equal weight when sample_weight is not provided.\n\n    max_features : int, float, string or None, optional (default=None)\n        The number of features to consider when looking for the best split:\n\n            - If int, then consider `max_features` features at each split.\n            - If float, then `max_features` is a fraction and\n              `int(max_features * n_features)` features are considered at each\n              split.\n            - If \"auto\", then `max_features=sqrt(n_features)`.\n            - If \"sqrt\", then `max_features=sqrt(n_features)`.\n            - If \"log2\", then `max_features=log2(n_features)`.\n            - If None, then `max_features=n_features`.\n\n        Note: the search for a split does not stop until at least one\n        valid partition of the node samples is found, even if it requires to\n        effectively inspect more than ``max_features`` features.\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    max_leaf_nodes : int or None, optional (default=None)\n        Grow a tree with ``max_leaf_nodes`` in best-first fashion.\n        Best nodes are defined as relative reduction in impurity.\n        If None then unlimited number of leaf nodes.\n\n    min_impurity_decrease : float, optional (default=0.)\n        A node will be split if this split induces a decrease of the impurity\n        greater than or equal to this value.\n\n        The weighted impurity decrease equation is the following::\n\n            N_t / N * (impurity - N_t_R / N_t * right_impurity\n                                - N_t_L / N_t * left_impurity)\n\n        where ``N`` is the total number of samples, ``N_t`` is the number of\n        samples at the current node, ``N_t_L`` is the number of samples in the\n        left child, and ``N_t_R`` is the number of samples in the right child.\n\n        ``N``, ``N_t``, ``N_t_R`` and ``N_t_L`` all refer to the weighted sum,\n        if ``sample_weight`` is passed.\n\n        .. versionadded:: 0.19\n\n    min_impurity_split : float,\n        Threshold for early stopping in tree growth. A node will split\n        if its impurity is above the threshold, otherwise it is a leaf.\n\n        .. deprecated:: 0.19\n           ``min_impurity_split`` has been deprecated in favor of\n           ``min_impurity_decrease`` in 0.19 and will be removed in 0.21.\n           Use ``min_impurity_decrease`` instead.\n\n    class_weight : dict, list of dicts, \"balanced\" or None, default=None\n        Weights associated with classes in the form ``{class_label: weight}``.\n        If not given, all classes are supposed to have weight one. For\n        multi-output problems, a list of dicts can be provided in the same\n        order as the columns of y.\n\n        Note that for multioutput (including multilabel) weights should be\n        defined for each class of every column in its own dict. For example,\n        for four-class multilabel classification weights should be\n        [{0: 1, 1: 1}, {0: 1, 1: 5}, {0: 1, 1: 1}, {0: 1, 1: 1}] instead of\n        [{1:1}, {2:5}, {3:1}, {4:1}].\n\n        The \"balanced\" mode uses the values of y to automatically adjust\n        weights inversely proportional to class frequencies in the input data\n        as ``n_samples / (n_classes * np.bincount(y))``\n\n        For multi-output, the weights of each column of y will be multiplied.\n\n        Note that these weights will be multiplied with sample_weight (passed\n        through the fit method) if sample_weight is specified.\n\n    presort : bool, optional (default=False)\n        Whether to presort the data to speed up the finding of best splits in\n        fitting. For the default settings of a decision tree on large\n        datasets, setting this to true may slow down the training process.\n        When using either a smaller dataset or a restricted depth, this may\n        speed up the training.\n\n    Attributes\n    ----------\n    classes_ : array of shape = [n_classes] or a list of such arrays\n        The classes labels (single output problem),\n        or a list of arrays of class labels (multi-output problem).\n\n    feature_importances_ : array of shape = [n_features]\n        The feature importances. The higher, the more important the\n        feature. The importance of a feature is computed as the (normalized)\n        total reduction of the criterion brought by that feature.  It is also\n        known as the Gini importance [4]_.\n\n    max_features_ : int,\n        The inferred value of max_features.\n\n    n_classes_ : int or list\n        The number of classes (for single output problems),\n        or a list containing the number of classes for each\n        output (for multi-output problems).\n\n    n_features_ : int\n        The number of features when ``fit`` is performed.\n\n    n_outputs_ : int\n        The number of outputs when ``fit`` is performed.\n\n    tree_ : Tree object\n        The underlying Tree object. Please refer to\n        ``help(sklearn.tree._tree.Tree)`` for attributes of Tree object and\n        :ref:`sphx_glr_auto_examples_tree_plot_unveil_tree_structure.py`\n        for basic usage of these attributes.\n\n    Notes\n    -----\n    The default values for the parameters controlling the size of the trees\n    (e.g. ``max_depth``, ``min_samples_leaf``, etc.) lead to fully grown and\n    unpruned trees which can potentially be very large on some data sets. To\n    reduce memory consumption, the complexity and size of the trees should be\n    controlled by setting those parameter values.\n\n    The features are always randomly permuted at each split. Therefore,\n    the best found split may vary, even with the same training data and\n    ``max_features=n_features``, if the improvement of the criterion is\n    identical for several splits enumerated during the search of the best\n    split. To obtain a deterministic behaviour during fitting,\n    ``random_state`` has to be fixed.\n\n    See also\n    --------\n    DecisionTreeRegressor\n\n    References\n    ----------\n\n    .. [1] https://en.wikipedia.org/wiki/Decision_tree_learning\n\n    .. [2] L. Breiman, J. Friedman, R. Olshen, and C. Stone, \"Classification\n           and Regression Trees\", Wadsworth, Belmont, CA, 1984.\n\n    .. [3] T. Hastie, R. Tibshirani and J. Friedman. \"Elements of Statistical\n           Learning\", Springer, 2009.\n\n    .. [4] L. Breiman, and A. Cutler, \"Random Forests\",\n           http://www.stat.berkeley.edu/~breiman/RandomForests/cc_home.htm\n\n    Examples\n    --------\n    >>> from sklearn.datasets import load_iris\n    >>> from sklearn.model_selection import cross_val_score\n    >>> from sklearn.tree import DecisionTreeClassifier\n    >>> clf = DecisionTreeClassifier(random_state=0)\n    >>> iris = load_iris()\n    >>> cross_val_score(clf, iris.data, iris.target, cv=10)\n    ...                             # doctest: +SKIP\n    ...\n    array([ 1.     ,  0.93...,  0.86...,  0.93...,  0.93...,\n            0.93...,  0.93...,  1.     ,  0.93...,  1.      ])\n    "
        }
    ],
    "transformers": [
        {
            "transformer": "sklearn.feature_extraction.text.HashingVectorizer",
            "name": "Hashing Vectorizer",
            "default_values": [
                {
                    "key": "alternate_sign",
                    "value": true,
                    "type_": "bool"
                },
                {
                    "key": "analyzer",
                    "value": "word",
                    "type_": "str"
                },
                {
                    "key": "binary",
                    "value": false,
                    "type_": "bool"
                },
                {
                    "key": "decode_error",
                    "value": "strict",
                    "type_": "str"
                },
                {
                    "key": "dtype",
                    "value": "float64",
                    "type_": "str"
                },
                {
                    "key": "encoding",
                    "value": "utf-8",
                    "type_": "str"
                },
                {
                    "key": "input",
                    "value": "content",
                    "type_": "str"
                },
                {
                    "key": "lowercase",
                    "value": true,
                    "type_": "bool"
                },
                {
                    "key": "n_features",
                    "value": 1048576,
                    "type_": "int"
                },
                {
                    "key": "ngram_range",
                    "value": [
                        1,
                        1
                    ],
                    "type_": "tuple"
                },
                {
                    "key": "non_negative",
                    "value": false,
                    "type_": "bool"
                },
                {
                    "key": "norm",
                    "value": "l2",
                    "type_": "str"
                },
                {
                    "key": "token_pattern",
                    "value": "(?u)\\b\\w\\w+\\b",
                    "type_": "str"
                }
            ],
            "doc_string": "Convert a collection of text documents to a matrix of token occurrences\n\n    It turns a collection of text documents into a scipy.sparse matrix holding\n    token occurrence counts (or binary occurrence information), possibly\n    normalized as token frequencies if norm='l1' or projected on the euclidean\n    unit sphere if norm='l2'.\n\n    This text vectorizer implementation uses the hashing trick to find the\n    token string name to feature integer index mapping.\n\n    This strategy has several advantages:\n\n    - it is very low memory scalable to large datasets as there is no need to\n      store a vocabulary dictionary in memory\n\n    - it is fast to pickle and un-pickle as it holds no state besides the\n      constructor parameters\n\n    - it can be used in a streaming (partial fit) or parallel pipeline as there\n      is no state computed during fit.\n\n    There are also a couple of cons (vs using a CountVectorizer with an\n    in-memory vocabulary):\n\n    - there is no way to compute the inverse transform (from feature indices to\n      string feature names) which can be a problem when trying to introspect\n      which features are most important to a model.\n\n    - there can be collisions: distinct tokens can be mapped to the same\n      feature index. However in practice this is rarely an issue if n_features\n      is large enough (e.g. 2 ** 18 for text classification problems).\n\n    - no IDF weighting as this would render the transformer stateful.\n\n    The hash function employed is the signed 32-bit version of Murmurhash3.\n\n    Read more in the :ref:`User Guide <text_feature_extraction>`.\n\n    Parameters\n    ----------\n\n    input : string {'filename', 'file', 'content'}\n        If 'filename', the sequence passed as an argument to fit is\n        expected to be a list of filenames that need reading to fetch\n        the raw content to analyze.\n\n        If 'file', the sequence items must have a 'read' method (file-like\n        object) that is called to fetch the bytes in memory.\n\n        Otherwise the input is expected to be the sequence strings or\n        bytes items are expected to be analyzed directly.\n\n    encoding : string, default='utf-8'\n        If bytes or files are given to analyze, this encoding is used to\n        decode.\n\n    decode_error : {'strict', 'ignore', 'replace'}\n        Instruction on what to do if a byte sequence is given to analyze that\n        contains characters not of the given `encoding`. By default, it is\n        'strict', meaning that a UnicodeDecodeError will be raised. Other\n        values are 'ignore' and 'replace'.\n\n    strip_accents : {'ascii', 'unicode', None}\n        Remove accents and perform other character normalization\n        during the preprocessing step.\n        'ascii' is a fast method that only works on characters that have\n        an direct ASCII mapping.\n        'unicode' is a slightly slower method that works on any characters.\n        None (default) does nothing.\n\n        Both 'ascii' and 'unicode' use NFKD normalization from\n        :func:`unicodedata.normalize`.\n\n    lowercase : boolean, default=True\n        Convert all characters to lowercase before tokenizing.\n\n    preprocessor : callable or None (default)\n        Override the preprocessing (string transformation) stage while\n        preserving the tokenizing and n-grams generation steps.\n\n    tokenizer : callable or None (default)\n        Override the string tokenization step while preserving the\n        preprocessing and n-grams generation steps.\n        Only applies if ``analyzer == 'word'``.\n\n    stop_words : string {'english'}, list, or None (default)\n        If 'english', a built-in stop word list for English is used.\n        There are several known issues with 'english' and you should\n        consider an alternative (see :ref:`stop_words`).\n\n        If a list, that list is assumed to contain stop words, all of which\n        will be removed from the resulting tokens.\n        Only applies if ``analyzer == 'word'``.\n\n    token_pattern : string\n        Regular expression denoting what constitutes a \"token\", only used\n        if ``analyzer == 'word'``. The default regexp selects tokens of 2\n        or more alphanumeric characters (punctuation is completely ignored\n        and always treated as a token separator).\n\n    ngram_range : tuple (min_n, max_n), default=(1, 1)\n        The lower and upper boundary of the range of n-values for different\n        n-grams to be extracted. All values of n such that min_n <= n <= max_n\n        will be used.\n\n    analyzer : string, {'word', 'char', 'char_wb'} or callable\n        Whether the feature should be made of word or character n-grams.\n        Option 'char_wb' creates character n-grams only from text inside\n        word boundaries; n-grams at the edges of words are padded with space.\n\n        If a callable is passed it is used to extract the sequence of features\n        out of the raw, unprocessed input.\n\n    n_features : integer, default=(2 ** 20)\n        The number of features (columns) in the output matrices. Small numbers\n        of features are likely to cause hash collisions, but large numbers\n        will cause larger coefficient dimensions in linear learners.\n\n    binary : boolean, default=False.\n        If True, all non zero counts are set to 1. This is useful for discrete\n        probabilistic models that model binary events rather than integer\n        counts.\n\n    norm : 'l1', 'l2' or None, optional\n        Norm used to normalize term vectors. None for no normalization.\n\n    alternate_sign : boolean, optional, default True\n        When True, an alternating sign is added to the features as to\n        approximately conserve the inner product in the hashed space even for\n        small n_features. This approach is similar to sparse random projection.\n\n        .. versionadded:: 0.19\n\n    non_negative : boolean, optional, default False\n        When True, an absolute value is applied to the features matrix prior to\n        returning it. When used in conjunction with alternate_sign=True, this\n        significantly reduces the inner product preservation property.\n\n        .. deprecated:: 0.19\n            This option will be removed in 0.21.\n    dtype : type, optional\n        Type of the matrix returned by fit_transform() or transform().\n\n    Examples\n    --------\n    >>> from sklearn.feature_extraction.text import HashingVectorizer\n    >>> corpus = [\n    ...     'This is the first document.',\n    ...     'This document is the second document.',\n    ...     'And this is the third one.',\n    ...     'Is this the first document?',\n    ... ]\n    >>> vectorizer = HashingVectorizer(n_features=2**4)\n    >>> X = vectorizer.fit_transform(corpus)\n    >>> print(X.shape)\n    (4, 16)\n\n    See also\n    --------\n    CountVectorizer, TfidfVectorizer\n\n    "
        },
        {
            "transformer": "klartext.transformers.AbsValueTransformer",
            "name": "Abs Value Transformer",
            "default_values": [],
            "doc_string": null
        },
        {
            "transformer": "klartext.transformers.LowerCasePreProcessor",
            "name": "Lower Case Pre Processor",
            "default_values": [],
            "doc_string": null
        },
        {
            "transformer": "klartext.transformers.StripAccentsAsciiPreProcessor",
            "name": "Strip Accents Ascii Pre Processor",
            "default_values": [],
            "doc_string": "\n\n    "
        },
        {
            "transformer": "klartext.transformers.WordLengthCounter",
            "name": "Word Length Counter",
            "default_values": [
                {
                    "key": "max_len",
                    "value": 10,
                    "type_": "int"
                },
                {
                    "key": "normalize",
                    "value": false,
                    "type_": "bool"
                }
            ],
            "doc_string": "\n    This transformers generates features representing the distribution of word lengths in the texts.\n    A word is simply a split on whitespace (special chars count thus as parts of the word).\n    The max length of words to consider can be given as parameter, words with length above max_len are\n    added to the same bucket.\n    "
        }
    ]
}
